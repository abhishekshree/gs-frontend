{"ast":null,"code":"'use strict';\n\nvar normalize = require('value-or-function');\nvar slice = Array.prototype.slice;\nfunction createResolver(config, options) {\n  // TODO: should the config object be validated?\n  config = config || {};\n  options = options || {};\n  var resolver = {\n    resolve: resolve\n  };\n\n  // Keep constants separately\n  var constants = {};\n  function resolveConstant(key) {\n    if (constants.hasOwnProperty(key)) {\n      return constants[key];\n    }\n    var definition = config[key];\n    // Ignore options that are not defined\n    if (!definition) {\n      return;\n    }\n    var option = options[key];\n    if (option != null) {\n      if (typeof option === 'function') {\n        return;\n      }\n      option = normalize.call(resolver, definition.type, option);\n      if (option != null) {\n        constants[key] = option;\n        return option;\n      }\n    }\n    var fallback = definition.default;\n    if (option == null && typeof fallback !== 'function') {\n      constants[key] = fallback;\n      return fallback;\n    }\n  }\n\n  // Keep requested keys to detect (and disallow) recursive resolution\n  var stack = [];\n  function resolve(key) {\n    var option = resolveConstant(key);\n    if (option != null) {\n      return option;\n    }\n    var definition = config[key];\n    // Ignore options that are not defined\n    if (!definition) {\n      return;\n    }\n    if (stack.indexOf(key) >= 0) {\n      throw new Error('Recursive resolution denied.');\n    }\n    option = options[key];\n    var fallback = definition.default;\n    var appliedArgs = slice.call(arguments, 1);\n    var args = [definition.type, option].concat(appliedArgs);\n    function toResolve() {\n      stack.push(key);\n      var option = normalize.apply(resolver, args);\n      if (option == null) {\n        option = fallback;\n        if (typeof option === 'function') {\n          option = option.apply(resolver, appliedArgs);\n        }\n      }\n      return option;\n    }\n    function onResolve() {\n      stack.pop();\n    }\n    return tryResolve(toResolve, onResolve);\n  }\n  return resolver;\n}\nfunction tryResolve(toResolve, onResolve) {\n  try {\n    return toResolve();\n  } finally {\n    onResolve();\n  }\n}\nmodule.exports = createResolver;","map":{"version":3,"names":["normalize","require","slice","Array","prototype","createResolver","config","options","resolver","resolve","constants","resolveConstant","key","hasOwnProperty","definition","option","call","type","fallback","default","stack","indexOf","Error","appliedArgs","arguments","args","concat","toResolve","push","apply","onResolve","pop","tryResolve","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/resolve-options/index.js"],"sourcesContent":["'use strict';\n\nvar normalize = require('value-or-function');\n\nvar slice = Array.prototype.slice;\n\nfunction createResolver(config, options) {\n  // TODO: should the config object be validated?\n  config = config || {};\n  options = options || {};\n\n  var resolver = {\n    resolve: resolve,\n  };\n\n\n  // Keep constants separately\n  var constants = {};\n\n  function resolveConstant(key) {\n    if (constants.hasOwnProperty(key)) {\n      return constants[key];\n    }\n\n    var definition = config[key];\n    // Ignore options that are not defined\n    if (!definition) {\n      return;\n    }\n\n    var option = options[key];\n\n    if (option != null) {\n      if (typeof option === 'function') {\n        return;\n      }\n      option = normalize.call(resolver, definition.type, option);\n      if (option != null) {\n        constants[key] = option;\n        return option;\n      }\n    }\n\n    var fallback = definition.default;\n    if (option == null && typeof fallback !== 'function') {\n      constants[key] = fallback;\n      return fallback;\n    }\n  }\n\n\n  // Keep requested keys to detect (and disallow) recursive resolution\n  var stack = [];\n\n  function resolve(key) {\n    var option = resolveConstant(key);\n    if (option != null) {\n      return option;\n    }\n\n    var definition = config[key];\n    // Ignore options that are not defined\n    if (!definition) {\n      return;\n    }\n\n    if (stack.indexOf(key) >= 0) {\n      throw new Error('Recursive resolution denied.');\n    }\n\n    option = options[key];\n    var fallback = definition.default;\n    var appliedArgs = slice.call(arguments, 1);\n    var args = [definition.type, option].concat(appliedArgs);\n\n    function toResolve() {\n      stack.push(key);\n      var option = normalize.apply(resolver, args);\n\n      if (option == null) {\n        option = fallback;\n        if (typeof option === 'function') {\n          option = option.apply(resolver, appliedArgs);\n        }\n      }\n\n      return option;\n    }\n\n    function onResolve() {\n      stack.pop();\n    }\n\n    return tryResolve(toResolve, onResolve);\n  }\n\n\n  return resolver;\n}\n\n\nfunction tryResolve(toResolve, onResolve) {\n  try {\n    return toResolve();\n  } finally {\n    onResolve();\n  }\n}\n\n\nmodule.exports = createResolver;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}