{"ast":null,"code":"'use strict';\n\nvar utils = module.exports;\nvar path = require('path');\n\n/**\n * Module dependencies\n */\n\nvar isWindows = require('is-windows')();\nvar Snapdragon = require('snapdragon');\nutils.define = require('define-property');\nutils.diff = require('arr-diff');\nutils.extend = require('extend-shallow');\nutils.pick = require('object.pick');\nutils.typeOf = require('kind-of');\nutils.unique = require('array-unique');\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nutils.isEmptyString = function (val) {\n  return String(val) === '' || String(val) === './';\n};\n\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\nutils.isWindows = function () {\n  return path.sep === '\\\\' || isWindows === true;\n};\n\n/**\n * Return the last element from an array\n */\n\nutils.last = function (arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Get the `Snapdragon` instance to use\n */\n\nutils.instantiate = function (ast, options) {\n  var snapdragon;\n  // if an instance was created by `.parse`, use that instance\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\n    snapdragon = ast.snapdragon;\n    // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\n    snapdragon = options.snapdragon;\n    // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n  utils.define(snapdragon, 'parse', function (str, options) {\n    var parsed = Snapdragon.prototype.parse.call(this, str, options);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last && this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n      if (last.type === 'bracket') {\n        if (inner.val.charAt(0) === '[') {\n          inner.val = '\\\\' + inner.val;\n        }\n      } else {\n        open.val = '\\\\' + open.val;\n        var sibling = open.parent.nodes[1];\n        if (sibling.type === 'star') {\n          sibling.loose = true;\n        }\n      }\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n  return snapdragon;\n};\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function (pattern, options) {\n  if (typeof options === 'undefined') {\n    return pattern;\n  }\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n  return key;\n};\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function (val) {\n  if (typeof val === 'string') return [val];\n  return val ? Array.isArray(val) ? val : [val] : [];\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isString = function (val) {\n  return typeof val === 'string';\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isRegex = function (val) {\n  return utils.typeOf(val) === 'regexp';\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isObject = function (val) {\n  return utils.typeOf(val) === 'object';\n};\n\n/**\n * Escape regex characters in the given string\n */\n\nutils.escapeRegex = function (str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\/\\s]/g, '\\\\$&');\n};\n\n/**\n * Combines duplicate characters in the provided `input` string.\n * @param {String} `input`\n * @returns {String}\n */\n\nutils.combineDupes = function (input, patterns) {\n  patterns = utils.arrayify(patterns).join('|').split('|');\n  patterns = patterns.map(function (s) {\n    return s.replace(/\\\\?([+*\\\\/])/g, '\\\\$1');\n  });\n  var substr = patterns.join('|');\n  var regex = new RegExp('(' + substr + ')(?=\\\\1)', 'g');\n  return input.replace(regex, '');\n};\n\n/**\n * Returns true if the given `str` has special characters\n */\n\nutils.hasSpecialChars = function (str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|[\\]{}]|[+@]\\()/.test(str);\n};\n\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\nutils.toPosixPath = function (str) {\n  return str.replace(/\\\\+/g, '/');\n};\n\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\nutils.unescape = function (str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\n};\n\n/**\n * Strip the drive letter from a windows filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripDrive = function (fp) {\n  return utils.isWindows() ? fp.replace(/^[a-z]:[\\\\/]+?/i, '/') : fp;\n};\n\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripPrefix = function (str) {\n  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\\\')) {\n    return str.slice(2);\n  }\n  return str;\n};\n\n/**\n * Returns true if `str` is a common character that doesn't need\n * to be processed to be used for matching.\n * @param {String} `str`\n * @return {Boolean}\n */\n\nutils.isSimpleChar = function (str) {\n  return str.trim() === '' || str === '.';\n};\n\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\nutils.isSlash = function (str) {\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.matchPath = function (pattern, options) {\n  return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\nutils._equals = function (filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\nutils._contains = function (filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.equalsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.containsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function (filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\nutils.matchBasename = function (re) {\n  return function (filepath) {\n    return re.test(filepath) || re.test(path.basename(filepath));\n  };\n};\n\n/**\n * Returns the given value unchanced.\n * @return {any}\n */\n\nutils.identity = function (val) {\n  return val;\n};\n\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\nutils.value = function (str, unixify, options) {\n  if (options && options.unixify === false) {\n    return str;\n  }\n  if (options && typeof options.unixify === 'function') {\n    return options.unixify(str);\n  }\n  return unixify(str);\n};\n\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\nutils.unixify = function (options) {\n  var opts = options || {};\n  return function (filepath) {\n    if (opts.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n    if (opts.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n    if (opts.unixify === true || utils.isWindows()) {\n      filepath = utils.toPosixPath(filepath);\n    }\n    return filepath;\n  };\n};","map":{"version":3,"names":["utils","module","exports","path","require","isWindows","Snapdragon","define","diff","extend","pick","typeOf","unique","isEmptyString","val","String","sep","last","arr","n","length","instantiate","ast","options","snapdragon","str","parsed","prototype","parse","call","input","parser","stack","pop","strictErrors","open","nodes","inner","type","charAt","sibling","parent","loose","createKey","pattern","key","prop","hasOwnProperty","arrayify","Array","isArray","isString","isRegex","isObject","escapeRegex","replace","combineDupes","patterns","join","split","map","s","substr","regex","RegExp","hasSpecialChars","test","toPosixPath","unescape","stripDrive","fp","stripPrefix","slice","isSimpleChar","trim","isSlash","matchPath","contains","containsPattern","equalsPattern","_equals","filepath","unixPath","_contains","indexOf","unixify","fn","equal","nocase","lower","toLowerCase","matchBasename","re","basename","identity","value","opts"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/nanomatch/lib/utils.js"],"sourcesContent":["'use strict';\n\nvar utils = module.exports;\nvar path = require('path');\n\n/**\n * Module dependencies\n */\n\nvar isWindows = require('is-windows')();\nvar Snapdragon = require('snapdragon');\nutils.define = require('define-property');\nutils.diff = require('arr-diff');\nutils.extend = require('extend-shallow');\nutils.pick = require('object.pick');\nutils.typeOf = require('kind-of');\nutils.unique = require('array-unique');\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nutils.isEmptyString = function(val) {\n  return String(val) === '' || String(val) === './';\n};\n\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\nutils.isWindows = function() {\n  return path.sep === '\\\\' || isWindows === true;\n};\n\n/**\n * Return the last element from an array\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Get the `Snapdragon` instance to use\n */\n\nutils.instantiate = function(ast, options) {\n  var snapdragon;\n  // if an instance was created by `.parse`, use that instance\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\n    snapdragon = ast.snapdragon;\n  // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\n    snapdragon = options.snapdragon;\n  // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, 'parse', function(str, options) {\n    var parsed = Snapdragon.prototype.parse.call(this, str, options);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last && this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n      if (last.type === 'bracket') {\n        if (inner.val.charAt(0) === '[') {\n          inner.val = '\\\\' + inner.val;\n        }\n\n      } else {\n        open.val = '\\\\' + open.val;\n        var sibling = open.parent.nodes[1];\n        if (sibling.type === 'star') {\n          sibling.loose = true;\n        }\n      }\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n\n  return snapdragon;\n};\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  if (typeof options === 'undefined') {\n    return pattern;\n  }\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n  return key;\n};\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === 'string') return [val];\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isString = function(val) {\n  return typeof val === 'string';\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isRegex = function(val) {\n  return utils.typeOf(val) === 'regexp';\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isObject = function(val) {\n  return utils.typeOf(val) === 'object';\n};\n\n/**\n * Escape regex characters in the given string\n */\n\nutils.escapeRegex = function(str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\/\\s]/g, '\\\\$&');\n};\n\n/**\n * Combines duplicate characters in the provided `input` string.\n * @param {String} `input`\n * @returns {String}\n */\n\nutils.combineDupes = function(input, patterns) {\n  patterns = utils.arrayify(patterns).join('|').split('|');\n  patterns = patterns.map(function(s) {\n    return s.replace(/\\\\?([+*\\\\/])/g, '\\\\$1');\n  });\n  var substr = patterns.join('|');\n  var regex = new RegExp('(' + substr + ')(?=\\\\1)', 'g');\n  return input.replace(regex, '');\n};\n\n/**\n * Returns true if the given `str` has special characters\n */\n\nutils.hasSpecialChars = function(str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|[\\]{}]|[+@]\\()/.test(str);\n};\n\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\nutils.toPosixPath = function(str) {\n  return str.replace(/\\\\+/g, '/');\n};\n\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\nutils.unescape = function(str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\n};\n\n/**\n * Strip the drive letter from a windows filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripDrive = function(fp) {\n  return utils.isWindows() ? fp.replace(/^[a-z]:[\\\\/]+?/i, '/') : fp;\n};\n\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripPrefix = function(str) {\n  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\\\')) {\n    return str.slice(2);\n  }\n  return str;\n};\n\n/**\n * Returns true if `str` is a common character that doesn't need\n * to be processed to be used for matching.\n * @param {String} `str`\n * @return {Boolean}\n */\n\nutils.isSimpleChar = function(str) {\n  return str.trim() === '' || str === '.';\n};\n\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\nutils.isSlash = function(str) {\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.matchPath = function(pattern, options) {\n  return (options && options.contains)\n    ? utils.containsPattern(pattern, options)\n    : utils.equalsPattern(pattern, options);\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\nutils._equals = function(filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\nutils._contains = function(filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.equalsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.containsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function(filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\nutils.matchBasename = function(re) {\n  return function(filepath) {\n    return re.test(filepath) || re.test(path.basename(filepath));\n  };\n};\n\n/**\n * Returns the given value unchanced.\n * @return {any}\n */\n\nutils.identity = function(val) {\n  return val;\n};\n\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\nutils.value = function(str, unixify, options) {\n  if (options && options.unixify === false) {\n    return str;\n  }\n  if (options && typeof options.unixify === 'function') {\n    return options.unixify(str);\n  }\n  return unixify(str);\n};\n\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\nutils.unixify = function(options) {\n  var opts = options || {};\n  return function(filepath) {\n    if (opts.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n    if (opts.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n    if (opts.unixify === true || utils.isWindows()) {\n      filepath = utils.toPosixPath(filepath);\n    }\n    return filepath;\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}