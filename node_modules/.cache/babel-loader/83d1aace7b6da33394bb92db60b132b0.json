{"ast":null,"code":"'use strict';\n\nvar use = require('use');\nvar util = require('util');\nvar Cache = require('map-cache');\nvar define = require('define-property');\nvar debug = require('debug')('snapdragon:parser');\nvar Position = require('./position');\nvar utils = require('./utils');\n\n/**\n * Create a new `Parser` with the given `input` and `options`.\n * @param {String} `input`\n * @param {Object} `options`\n * @api public\n */\n\nfunction Parser(options) {\n  debug('initializing', __filename);\n  this.options = utils.extend({\n    source: 'string'\n  }, options);\n  this.init(this.options);\n  use(this);\n}\n\n/**\n * Prototype methods\n */\n\nParser.prototype = {\n  constructor: Parser,\n  init: function (options) {\n    this.orig = '';\n    this.input = '';\n    this.parsed = '';\n    this.column = 1;\n    this.line = 1;\n    this.regex = new Cache();\n    this.errors = this.errors || [];\n    this.parsers = this.parsers || {};\n    this.types = this.types || [];\n    this.sets = this.sets || {};\n    this.fns = this.fns || [];\n    this.currentType = 'root';\n    var pos = this.position();\n    this.bos = pos({\n      type: 'bos',\n      val: ''\n    });\n    this.ast = {\n      type: 'root',\n      errors: this.errors,\n      nodes: [this.bos]\n    };\n    define(this.bos, 'parent', this.ast);\n    this.nodes = [this.ast];\n    this.count = 0;\n    this.setCount = 0;\n    this.stack = [];\n  },\n  /**\n   * Throw a formatted error with the cursor column and `msg`.\n   * @param {String} `msg` Message to use in the Error.\n   */\n\n  error: function (msg, node) {\n    var pos = node.position || {\n      start: {\n        column: 0,\n        line: 0\n      }\n    };\n    var line = pos.start.line;\n    var column = pos.start.column;\n    var source = this.options.source;\n    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;\n    var err = new Error(message);\n    err.source = source;\n    err.reason = msg;\n    err.pos = pos;\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n  /**\n   * Define a non-enumberable property on the `Parser` instance.\n   *\n   * ```js\n   * parser.define('foo', 'bar');\n   * ```\n   * @name .define\n   * @param {String} `key` propery name\n   * @param {any} `val` property value\n   * @return {Object} Returns the Parser instance for chaining.\n   * @api public\n   */\n\n  define: function (key, val) {\n    define(this, key, val);\n    return this;\n  },\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  position: function () {\n    var start = {\n      line: this.line,\n      column: this.column\n    };\n    var self = this;\n    return function (node) {\n      define(node, 'position', new Position(start, self));\n      return node;\n    };\n  },\n  /**\n   * Set parser `name` with the given `fn`\n   * @param {String} `name`\n   * @param {Function} `fn`\n   * @api public\n   */\n\n  set: function (type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n    this.parsers[type] = fn.bind(this);\n    return this;\n  },\n  /**\n   * Get parser `name`\n   * @param {String} `name`\n   * @api public\n   */\n\n  get: function (name) {\n    return this.parsers[name];\n  },\n  /**\n   * Push a `token` onto the `type` stack.\n   *\n   * @param {String} `type`\n   * @return {Object} `token`\n   * @api public\n   */\n\n  push: function (type, token) {\n    this.sets[type] = this.sets[type] || [];\n    this.count++;\n    this.stack.push(token);\n    return this.sets[type].push(token);\n  },\n  /**\n   * Pop a token off of the `type` stack\n   * @param {String} `type`\n   * @returns {Object} Returns a token\n   * @api public\n   */\n\n  pop: function (type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  },\n  /**\n   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.\n   *\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isInside: function (type) {\n    this.sets[type] = this.sets[type] || [];\n    return this.sets[type].length > 0;\n  },\n  /**\n   * Return true if `node` is the given `type`.\n   *\n   * ```js\n   * parser.isType(node, 'brace');\n   * ```\n   * @param {Object} `node`\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isType: function (node, type) {\n    return node && node.type === type;\n  },\n  /**\n   * Get the previous AST node\n   * @return {Object}\n   */\n\n  prev: function (n) {\n    return this.stack.length > 0 ? utils.last(this.stack, n) : utils.last(this.nodes, n);\n  },\n  /**\n   * Update line and column based on `str`.\n   */\n\n  consume: function (len) {\n    this.input = this.input.substr(len);\n  },\n  /**\n   * Update column based on `str`.\n   */\n\n  updatePosition: function (str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf('\\n');\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  },\n  /**\n   * Match `regex`, return captures, and update the cursor position by `match[0]` length.\n   * @param {RegExp} `regex`\n   * @return {Object}\n   */\n\n  match: function (regex) {\n    var m = regex.exec(this.input);\n    if (m) {\n      this.updatePosition(m[0], m[0].length);\n      return m;\n    }\n  },\n  /**\n   * Capture `type` with the given regex.\n   * @param {String} `type`\n   * @param {RegExp} `regex`\n   * @return {Function}\n   */\n\n  capture: function (type, regex) {\n    if (typeof regex === 'function') {\n      return this.set.apply(this, arguments);\n    }\n    this.regex.set(type, regex);\n    this.set(type, function () {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(regex);\n      if (!m || !m[0]) return;\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        val: m[0],\n        parsed: parsed,\n        rest: this.input\n      });\n      if (m[1]) {\n        node.inner = m[1];\n      }\n      define(node, 'inside', this.stack.length > 0);\n      define(node, 'parent', prev);\n      prev.nodes.push(node);\n    }.bind(this));\n    return this;\n  },\n  /**\n   * Create a parser with open and close for parens,\n   * brackets or braces\n   */\n\n  capturePair: function (type, openRegex, closeRegex, fn) {\n    this.sets[type] = this.sets[type] || [];\n\n    /**\n     * Open\n     */\n\n    this.set(type + '.open', function () {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(openRegex);\n      if (!m || !m[0]) return;\n      var val = m[0];\n      this.setCount++;\n      this.specialChars = true;\n      var open = pos({\n        type: type + '.open',\n        val: val,\n        rest: this.input\n      });\n      if (typeof m[1] !== 'undefined') {\n        open.inner = m[1];\n      }\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        nodes: [open]\n      });\n      define(node, 'rest', this.input);\n      define(node, 'parsed', parsed);\n      define(node, 'prefix', m[1]);\n      define(node, 'parent', prev);\n      define(open, 'parent', node);\n      if (typeof fn === 'function') {\n        fn.call(this, open, node);\n      }\n      this.push(type, node);\n      prev.nodes.push(node);\n    });\n\n    /**\n     * Close\n     */\n\n    this.set(type + '.close', function () {\n      var pos = this.position();\n      var m = this.match(closeRegex);\n      if (!m || !m[0]) return;\n      var parent = this.pop(type);\n      var node = pos({\n        type: type + '.close',\n        rest: this.input,\n        suffix: m[1],\n        val: m[0]\n      });\n      if (!this.isType(parent, type)) {\n        if (this.options.strict) {\n          throw new Error('missing opening \"' + type + '\"');\n        }\n        this.setCount--;\n        node.escaped = true;\n        return node;\n      }\n      if (node.suffix === '\\\\') {\n        parent.escaped = true;\n        node.escaped = true;\n      }\n      parent.nodes.push(node);\n      define(node, 'parent', parent);\n    });\n    return this;\n  },\n  /**\n   * Capture end-of-string\n   */\n\n  eos: function () {\n    var pos = this.position();\n    if (this.input) return;\n    var prev = this.prev();\n    while (prev.type !== 'root' && !prev.visited) {\n      if (this.options.strict === true) {\n        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));\n      }\n      if (!hasDelims(prev)) {\n        prev.parent.escaped = true;\n        prev.escaped = true;\n      }\n      visit(prev, function (node) {\n        if (!hasDelims(node.parent)) {\n          node.parent.escaped = true;\n          node.escaped = true;\n        }\n      });\n      prev = prev.parent;\n    }\n    var tok = pos({\n      type: 'eos',\n      val: this.append || ''\n    });\n    define(tok, 'parent', this.ast);\n    return tok;\n  },\n  /**\n   * Run parsers to advance the cursor position\n   */\n\n  next: function () {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n    while (++idx < len) {\n      if (tok = this.parsers[this.types[idx]].call(this)) {\n        define(tok, 'rest', this.input);\n        define(tok, 'parsed', parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  },\n  /**\n   * Parse the given string.\n   * @return {Array}\n   */\n\n  parse: function (input) {\n    if (typeof input !== 'string') {\n      throw new TypeError('expected a string');\n    }\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input;\n\n      // get the next AST ndoe\n      var node = self.next();\n      if (node) {\n        var prev = self.prev();\n        if (prev) {\n          define(node, 'parent', prev);\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      }\n\n      // if we got here but input is not changed, throw an error\n      if (self.input && input === self.input) {\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\n      }\n    }\n    while (this.input) parse();\n    if (this.stack.length && this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\n    }\n    var eos = this.eos();\n    var tok = this.prev();\n    if (tok.type !== 'eos') {\n      this.ast.nodes.push(eos);\n    }\n    return this.ast;\n  }\n};\n\n/**\n * Visit `node` with the given `fn`\n */\n\nfunction visit(node, fn) {\n  if (!node.visited) {\n    define(node, 'visited', true);\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n  return node;\n}\n\n/**\n * Map visit over array of `nodes`.\n */\n\nfunction mapVisit(nodes, fn) {\n  var len = nodes.length;\n  var idx = -1;\n  while (++idx < len) {\n    visit(nodes[idx], fn);\n  }\n}\nfunction hasOpen(node) {\n  return node.nodes && node.nodes[0].type === node.type + '.open';\n}\nfunction hasClose(node) {\n  return node.nodes && utils.last(node.nodes).type === node.type + '.close';\n}\nfunction hasDelims(node) {\n  return hasOpen(node) && hasClose(node);\n}\n\n/**\n * Expose `Parser`\n */\n\nmodule.exports = Parser;","map":{"version":3,"names":["use","require","util","Cache","define","debug","Position","utils","Parser","options","__filename","extend","source","init","prototype","constructor","orig","input","parsed","column","line","regex","errors","parsers","types","sets","fns","currentType","pos","position","bos","type","val","ast","nodes","count","setCount","stack","error","msg","node","start","message","err","Error","reason","silent","push","key","self","set","fn","indexOf","bind","get","name","token","pop","isInside","length","isType","prev","n","last","consume","len","substr","updatePosition","str","lines","match","i","lastIndexOf","m","exec","capture","apply","arguments","rest","inner","capturePair","openRegex","closeRegex","specialChars","open","call","parent","suffix","strict","escaped","eos","visited","SyntaxError","inspect","hasDelims","visit","tok","append","next","idx","parse","TypeError","hasOwnProperty","slice","mapVisit","hasOpen","hasClose","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/snapdragon/lib/parser.js"],"sourcesContent":["'use strict';\n\nvar use = require('use');\nvar util = require('util');\nvar Cache = require('map-cache');\nvar define = require('define-property');\nvar debug = require('debug')('snapdragon:parser');\nvar Position = require('./position');\nvar utils = require('./utils');\n\n/**\n * Create a new `Parser` with the given `input` and `options`.\n * @param {String} `input`\n * @param {Object} `options`\n * @api public\n */\n\nfunction Parser(options) {\n  debug('initializing', __filename);\n  this.options = utils.extend({source: 'string'}, options);\n  this.init(this.options);\n  use(this);\n}\n\n/**\n * Prototype methods\n */\n\nParser.prototype = {\n  constructor: Parser,\n\n  init: function(options) {\n    this.orig = '';\n    this.input = '';\n    this.parsed = '';\n\n    this.column = 1;\n    this.line = 1;\n\n    this.regex = new Cache();\n    this.errors = this.errors || [];\n    this.parsers = this.parsers || {};\n    this.types = this.types || [];\n    this.sets = this.sets || {};\n    this.fns = this.fns || [];\n    this.currentType = 'root';\n\n    var pos = this.position();\n    this.bos = pos({type: 'bos', val: ''});\n\n    this.ast = {\n      type: 'root',\n      errors: this.errors,\n      nodes: [this.bos]\n    };\n\n    define(this.bos, 'parent', this.ast);\n    this.nodes = [this.ast];\n\n    this.count = 0;\n    this.setCount = 0;\n    this.stack = [];\n  },\n\n  /**\n   * Throw a formatted error with the cursor column and `msg`.\n   * @param {String} `msg` Message to use in the Error.\n   */\n\n  error: function(msg, node) {\n    var pos = node.position || {start: {column: 0, line: 0}};\n    var line = pos.start.line;\n    var column = pos.start.column;\n    var source = this.options.source;\n\n    var message = source + ' <line:' + line + ' column:' + column + '>: ' + msg;\n    var err = new Error(message);\n    err.source = source;\n    err.reason = msg;\n    err.pos = pos;\n\n    if (this.options.silent) {\n      this.errors.push(err);\n    } else {\n      throw err;\n    }\n  },\n\n  /**\n   * Define a non-enumberable property on the `Parser` instance.\n   *\n   * ```js\n   * parser.define('foo', 'bar');\n   * ```\n   * @name .define\n   * @param {String} `key` propery name\n   * @param {any} `val` property value\n   * @return {Object} Returns the Parser instance for chaining.\n   * @api public\n   */\n\n  define: function(key, val) {\n    define(this, key, val);\n    return this;\n  },\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  position: function() {\n    var start = { line: this.line, column: this.column };\n    var self = this;\n\n    return function(node) {\n      define(node, 'position', new Position(start, self));\n      return node;\n    };\n  },\n\n  /**\n   * Set parser `name` with the given `fn`\n   * @param {String} `name`\n   * @param {Function} `fn`\n   * @api public\n   */\n\n  set: function(type, fn) {\n    if (this.types.indexOf(type) === -1) {\n      this.types.push(type);\n    }\n    this.parsers[type] = fn.bind(this);\n    return this;\n  },\n\n  /**\n   * Get parser `name`\n   * @param {String} `name`\n   * @api public\n   */\n\n  get: function(name) {\n    return this.parsers[name];\n  },\n\n  /**\n   * Push a `token` onto the `type` stack.\n   *\n   * @param {String} `type`\n   * @return {Object} `token`\n   * @api public\n   */\n\n  push: function(type, token) {\n    this.sets[type] = this.sets[type] || [];\n    this.count++;\n    this.stack.push(token);\n    return this.sets[type].push(token);\n  },\n\n  /**\n   * Pop a token off of the `type` stack\n   * @param {String} `type`\n   * @returns {Object} Returns a token\n   * @api public\n   */\n\n  pop: function(type) {\n    this.sets[type] = this.sets[type] || [];\n    this.count--;\n    this.stack.pop();\n    return this.sets[type].pop();\n  },\n\n  /**\n   * Return true if inside a `stack` node. Types are `braces`, `parens` or `brackets`.\n   *\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isInside: function(type) {\n    this.sets[type] = this.sets[type] || [];\n    return this.sets[type].length > 0;\n  },\n\n  /**\n   * Return true if `node` is the given `type`.\n   *\n   * ```js\n   * parser.isType(node, 'brace');\n   * ```\n   * @param {Object} `node`\n   * @param {String} `type`\n   * @return {Boolean}\n   * @api public\n   */\n\n  isType: function(node, type) {\n    return node && node.type === type;\n  },\n\n  /**\n   * Get the previous AST node\n   * @return {Object}\n   */\n\n  prev: function(n) {\n    return this.stack.length > 0\n      ? utils.last(this.stack, n)\n      : utils.last(this.nodes, n);\n  },\n\n  /**\n   * Update line and column based on `str`.\n   */\n\n  consume: function(len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Update column based on `str`.\n   */\n\n  updatePosition: function(str, len) {\n    var lines = str.match(/\\n/g);\n    if (lines) this.line += lines.length;\n    var i = str.lastIndexOf('\\n');\n    this.column = ~i ? len - i : this.column + len;\n    this.parsed += str;\n    this.consume(len);\n  },\n\n  /**\n   * Match `regex`, return captures, and update the cursor position by `match[0]` length.\n   * @param {RegExp} `regex`\n   * @return {Object}\n   */\n\n  match: function(regex) {\n    var m = regex.exec(this.input);\n    if (m) {\n      this.updatePosition(m[0], m[0].length);\n      return m;\n    }\n  },\n\n  /**\n   * Capture `type` with the given regex.\n   * @param {String} `type`\n   * @param {RegExp} `regex`\n   * @return {Function}\n   */\n\n  capture: function(type, regex) {\n    if (typeof regex === 'function') {\n      return this.set.apply(this, arguments);\n    }\n\n    this.regex.set(type, regex);\n    this.set(type, function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(regex);\n      if (!m || !m[0]) return;\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        val: m[0],\n        parsed: parsed,\n        rest: this.input\n      });\n\n      if (m[1]) {\n        node.inner = m[1];\n      }\n\n      define(node, 'inside', this.stack.length > 0);\n      define(node, 'parent', prev);\n      prev.nodes.push(node);\n    }.bind(this));\n    return this;\n  },\n\n  /**\n   * Create a parser with open and close for parens,\n   * brackets or braces\n   */\n\n  capturePair: function(type, openRegex, closeRegex, fn) {\n    this.sets[type] = this.sets[type] || [];\n\n    /**\n     * Open\n     */\n\n    this.set(type + '.open', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(openRegex);\n      if (!m || !m[0]) return;\n\n      var val = m[0];\n      this.setCount++;\n      this.specialChars = true;\n      var open = pos({\n        type: type + '.open',\n        val: val,\n        rest: this.input\n      });\n\n      if (typeof m[1] !== 'undefined') {\n        open.inner = m[1];\n      }\n\n      var prev = this.prev();\n      var node = pos({\n        type: type,\n        nodes: [open]\n      });\n\n      define(node, 'rest', this.input);\n      define(node, 'parsed', parsed);\n      define(node, 'prefix', m[1]);\n      define(node, 'parent', prev);\n      define(open, 'parent', node);\n\n      if (typeof fn === 'function') {\n        fn.call(this, open, node);\n      }\n\n      this.push(type, node);\n      prev.nodes.push(node);\n    });\n\n    /**\n     * Close\n     */\n\n    this.set(type + '.close', function() {\n      var pos = this.position();\n      var m = this.match(closeRegex);\n      if (!m || !m[0]) return;\n\n      var parent = this.pop(type);\n      var node = pos({\n        type: type + '.close',\n        rest: this.input,\n        suffix: m[1],\n        val: m[0]\n      });\n\n      if (!this.isType(parent, type)) {\n        if (this.options.strict) {\n          throw new Error('missing opening \"' + type + '\"');\n        }\n\n        this.setCount--;\n        node.escaped = true;\n        return node;\n      }\n\n      if (node.suffix === '\\\\') {\n        parent.escaped = true;\n        node.escaped = true;\n      }\n\n      parent.nodes.push(node);\n      define(node, 'parent', parent);\n    });\n\n    return this;\n  },\n\n  /**\n   * Capture end-of-string\n   */\n\n  eos: function() {\n    var pos = this.position();\n    if (this.input) return;\n    var prev = this.prev();\n\n    while (prev.type !== 'root' && !prev.visited) {\n      if (this.options.strict === true) {\n        throw new SyntaxError('invalid syntax:' + util.inspect(prev, null, 2));\n      }\n\n      if (!hasDelims(prev)) {\n        prev.parent.escaped = true;\n        prev.escaped = true;\n      }\n\n      visit(prev, function(node) {\n        if (!hasDelims(node.parent)) {\n          node.parent.escaped = true;\n          node.escaped = true;\n        }\n      });\n\n      prev = prev.parent;\n    }\n\n    var tok = pos({\n      type: 'eos',\n      val: this.append || ''\n    });\n\n    define(tok, 'parent', this.ast);\n    return tok;\n  },\n\n  /**\n   * Run parsers to advance the cursor position\n   */\n\n  next: function() {\n    var parsed = this.parsed;\n    var len = this.types.length;\n    var idx = -1;\n    var tok;\n\n    while (++idx < len) {\n      if ((tok = this.parsers[this.types[idx]].call(this))) {\n        define(tok, 'rest', this.input);\n        define(tok, 'parsed', parsed);\n        this.last = tok;\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Parse the given string.\n   * @return {Array}\n   */\n\n  parse: function(input) {\n    if (typeof input !== 'string') {\n      throw new TypeError('expected a string');\n    }\n\n    this.init(this.options);\n    this.orig = input;\n    this.input = input;\n    var self = this;\n\n    function parse() {\n      // check input before calling `.next()`\n      input = self.input;\n\n      // get the next AST ndoe\n      var node = self.next();\n      if (node) {\n        var prev = self.prev();\n        if (prev) {\n          define(node, 'parent', prev);\n          if (prev.nodes) {\n            prev.nodes.push(node);\n          }\n        }\n\n        if (self.sets.hasOwnProperty(prev.type)) {\n          self.currentType = prev.type;\n        }\n      }\n\n      // if we got here but input is not changed, throw an error\n      if (self.input && input === self.input) {\n        throw new Error('no parsers registered for: \"' + self.input.slice(0, 5) + '\"');\n      }\n    }\n\n    while (this.input) parse();\n    if (this.stack.length && this.options.strict) {\n      var node = this.stack.pop();\n      throw this.error('missing opening ' + node.type + ': \"' + this.orig + '\"');\n    }\n\n    var eos = this.eos();\n    var tok = this.prev();\n    if (tok.type !== 'eos') {\n      this.ast.nodes.push(eos);\n    }\n\n    return this.ast;\n  }\n};\n\n/**\n * Visit `node` with the given `fn`\n */\n\nfunction visit(node, fn) {\n  if (!node.visited) {\n    define(node, 'visited', true);\n    return node.nodes ? mapVisit(node.nodes, fn) : fn(node);\n  }\n  return node;\n}\n\n/**\n * Map visit over array of `nodes`.\n */\n\nfunction mapVisit(nodes, fn) {\n  var len = nodes.length;\n  var idx = -1;\n  while (++idx < len) {\n    visit(nodes[idx], fn);\n  }\n}\n\nfunction hasOpen(node) {\n  return node.nodes && node.nodes[0].type === (node.type + '.open');\n}\n\nfunction hasClose(node) {\n  return node.nodes && utils.last(node.nodes).type === (node.type + '.close');\n}\n\nfunction hasDelims(node) {\n  return hasOpen(node) && hasClose(node);\n}\n\n/**\n * Expose `Parser`\n */\n\nmodule.exports = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}