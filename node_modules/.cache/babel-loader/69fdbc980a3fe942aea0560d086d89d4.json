{"ast":null,"code":"'use strict';\n\nvar chokidar = require('chokidar');\nvar debounce = require('just-debounce');\nvar asyncDone = require('async-done');\nvar defaults = require('object.defaults/immutable');\nvar isNegatedGlob = require('is-negated-glob');\nvar anymatch = require('anymatch');\nvar normalize = require('normalize-path');\nvar defaultOpts = {\n  delay: 200,\n  events: ['add', 'change', 'unlink'],\n  ignored: [],\n  ignoreInitial: true,\n  queue: true\n};\nfunction listenerCount(ee, evtName) {\n  if (typeof ee.listenerCount === 'function') {\n    return ee.listenerCount(evtName);\n  }\n  return ee.listeners(evtName).length;\n}\nfunction hasErrorListener(ee) {\n  return listenerCount(ee, 'error') !== 0;\n}\nfunction exists(val) {\n  return val != null;\n}\nfunction watch(glob, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  var opt = defaults(options, defaultOpts);\n  if (!Array.isArray(opt.events)) {\n    opt.events = [opt.events];\n  }\n  if (Array.isArray(glob)) {\n    // We slice so we don't mutate the passed globs array\n    glob = glob.slice();\n  } else {\n    glob = [glob];\n  }\n  var queued = false;\n  var running = false;\n\n  // These use sparse arrays to keep track of the index in the\n  // original globs array\n  var positives = new Array(glob.length);\n  var negatives = new Array(glob.length);\n\n  // Reverse the glob here so we don't end up with a positive\n  // and negative glob in position 0 after a reverse\n  glob.reverse().forEach(sortGlobs);\n  function sortGlobs(globString, index) {\n    var result = isNegatedGlob(globString);\n    if (result.negated) {\n      negatives[index] = result.pattern;\n    } else {\n      positives[index] = result.pattern;\n    }\n  }\n  var toWatch = positives.filter(exists);\n  function joinCwd(glob) {\n    if (glob && opt.cwd) {\n      return normalize(opt.cwd + '/' + glob);\n    }\n    return glob;\n  }\n\n  // We only do add our custom `ignored` if there are some negative globs\n  // TODO: I'm not sure how to test this\n  if (negatives.some(exists)) {\n    var normalizedPositives = positives.map(joinCwd);\n    var normalizedNegatives = negatives.map(joinCwd);\n    var shouldBeIgnored = function (path) {\n      var positiveMatch = anymatch(normalizedPositives, path, true);\n      var negativeMatch = anymatch(normalizedNegatives, path, true);\n      // If negativeMatch is -1, that means it was never negated\n      if (negativeMatch === -1) {\n        return false;\n      }\n\n      // If the negative is \"less than\" the positive, that means\n      // it came later in the glob array before we reversed them\n      return negativeMatch < positiveMatch;\n    };\n    opt.ignored = [].concat(opt.ignored, shouldBeIgnored);\n  }\n  var watcher = chokidar.watch(toWatch, opt);\n  function runComplete(err) {\n    running = false;\n    if (err && hasErrorListener(watcher)) {\n      watcher.emit('error', err);\n    }\n\n    // If we have a run queued, start onChange again\n    if (queued) {\n      queued = false;\n      onChange();\n    }\n  }\n  function onChange() {\n    if (running) {\n      if (opt.queue) {\n        queued = true;\n      }\n      return;\n    }\n    running = true;\n    asyncDone(cb, runComplete);\n  }\n  var fn;\n  if (typeof cb === 'function') {\n    fn = debounce(onChange, opt.delay);\n  }\n  function watchEvent(eventName) {\n    watcher.on(eventName, fn);\n  }\n  if (fn) {\n    opt.events.forEach(watchEvent);\n  }\n  return watcher;\n}\nmodule.exports = watch;","map":{"version":3,"names":["chokidar","require","debounce","asyncDone","defaults","isNegatedGlob","anymatch","normalize","defaultOpts","delay","events","ignored","ignoreInitial","queue","listenerCount","ee","evtName","listeners","length","hasErrorListener","exists","val","watch","glob","options","cb","opt","Array","isArray","slice","queued","running","positives","negatives","reverse","forEach","sortGlobs","globString","index","result","negated","pattern","toWatch","filter","joinCwd","cwd","some","normalizedPositives","map","normalizedNegatives","shouldBeIgnored","path","positiveMatch","negativeMatch","concat","watcher","runComplete","err","emit","onChange","fn","watchEvent","eventName","on","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/glob-watcher/index.js"],"sourcesContent":["'use strict';\n\nvar chokidar = require('chokidar');\nvar debounce = require('just-debounce');\nvar asyncDone = require('async-done');\nvar defaults = require('object.defaults/immutable');\nvar isNegatedGlob = require('is-negated-glob');\nvar anymatch = require('anymatch');\nvar normalize = require('normalize-path');\n\nvar defaultOpts = {\n  delay: 200,\n  events: ['add', 'change', 'unlink'],\n  ignored: [],\n  ignoreInitial: true,\n  queue: true,\n};\n\nfunction listenerCount(ee, evtName) {\n  if (typeof ee.listenerCount === 'function') {\n    return ee.listenerCount(evtName);\n  }\n\n  return ee.listeners(evtName).length;\n}\n\nfunction hasErrorListener(ee) {\n  return listenerCount(ee, 'error') !== 0;\n}\n\nfunction exists(val) {\n  return val != null;\n}\n\nfunction watch(glob, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  var opt = defaults(options, defaultOpts);\n\n  if (!Array.isArray(opt.events)) {\n    opt.events = [opt.events];\n  }\n\n  if (Array.isArray(glob)) {\n    // We slice so we don't mutate the passed globs array\n    glob = glob.slice();\n  } else {\n    glob = [glob];\n  }\n\n  var queued = false;\n  var running = false;\n\n  // These use sparse arrays to keep track of the index in the\n  // original globs array\n  var positives = new Array(glob.length);\n  var negatives = new Array(glob.length);\n\n  // Reverse the glob here so we don't end up with a positive\n  // and negative glob in position 0 after a reverse\n  glob.reverse().forEach(sortGlobs);\n\n  function sortGlobs(globString, index) {\n    var result = isNegatedGlob(globString);\n    if (result.negated) {\n      negatives[index] = result.pattern;\n    } else {\n      positives[index] = result.pattern;\n    }\n  }\n\n  var toWatch = positives.filter(exists);\n\n  function joinCwd(glob) {\n    if (glob && opt.cwd) {\n      return normalize(opt.cwd + '/' + glob);\n    }\n\n    return glob;\n  }\n\n  // We only do add our custom `ignored` if there are some negative globs\n  // TODO: I'm not sure how to test this\n  if (negatives.some(exists)) {\n    var normalizedPositives = positives.map(joinCwd);\n    var normalizedNegatives = negatives.map(joinCwd);\n    var shouldBeIgnored = function(path) {\n      var positiveMatch = anymatch(normalizedPositives, path, true);\n      var negativeMatch = anymatch(normalizedNegatives, path, true);\n      // If negativeMatch is -1, that means it was never negated\n      if (negativeMatch === -1) {\n        return false;\n      }\n\n      // If the negative is \"less than\" the positive, that means\n      // it came later in the glob array before we reversed them\n      return negativeMatch < positiveMatch;\n    };\n\n    opt.ignored = [].concat(opt.ignored, shouldBeIgnored);\n  }\n  var watcher = chokidar.watch(toWatch, opt);\n\n  function runComplete(err) {\n    running = false;\n\n    if (err && hasErrorListener(watcher)) {\n      watcher.emit('error', err);\n    }\n\n    // If we have a run queued, start onChange again\n    if (queued) {\n      queued = false;\n      onChange();\n    }\n  }\n\n  function onChange() {\n    if (running) {\n      if (opt.queue) {\n        queued = true;\n      }\n      return;\n    }\n\n    running = true;\n    asyncDone(cb, runComplete);\n  }\n\n  var fn;\n  if (typeof cb === 'function') {\n    fn = debounce(onChange, opt.delay);\n  }\n\n  function watchEvent(eventName) {\n    watcher.on(eventName, fn);\n  }\n\n  if (fn) {\n    opt.events.forEach(watchEvent);\n  }\n\n  return watcher;\n}\n\nmodule.exports = watch;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}