{"ast":null,"code":"'use strict';\n\nvar typeOf = require('kind-of');\nvar utils = module.exports;\n\n/**\n * Returns true if the given value is a node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isNode(node)); //=> true\n * console.log(utils.isNode({})); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Boolean}\n * @api public\n */\n\nutils.isNode = function (node) {\n  return typeOf(node) === 'object' && node.isNode === true;\n};\n\n/**\n * Emit an empty string for the given `node`.\n *\n * ```js\n * // do nothing for beginning-of-string\n * snapdragon.compiler.set('bos', utils.noop);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.noop = function (node) {\n  append(this, '', node);\n};\n\n/**\n * Appdend `node.val` to `compiler.output`, exactly as it was created\n * by the parser.\n *\n * ```js\n * snapdragon.compiler.set('text', utils.identity);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.identity = function (node) {\n  append(this, node.val, node);\n};\n\n/**\n * Previously named `.emit`, this method appends the given `val`\n * to `compiler.output` for the given node. Useful when you know\n * what value should be appended advance, regardless of the actual\n * value of `node.val`.\n *\n * ```js\n * snapdragon.compiler\n *   .set('i', function(node) {\n *     this.mapVisit(node);\n *   })\n *   .set('i.open', utils.append('<i>'))\n *   .set('i.close', utils.append('</i>'))\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Function} Returns a compiler middleware function.\n * @api public\n */\n\nutils.append = function (val) {\n  return function (node) {\n    append(this, val, node);\n  };\n};\n\n/**\n * Used in compiler middleware, this onverts an AST node into\n * an empty `text` node and deletes `node.nodes` if it exists.\n * The advantage of this method is that, as opposed to completely\n * removing the node, indices will not need to be re-calculated\n * in sibling nodes, and nothing is appended to the output.\n *\n * ```js\n * utils.toNoop(node);\n * // convert `node.nodes` to the given value instead of deleting it\n * utils.toNoop(node, []);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.\n * @api public\n */\n\nutils.toNoop = function (node, nodes) {\n  if (nodes) {\n    node.nodes = nodes;\n  } else {\n    delete node.nodes;\n    node.type = 'text';\n    node.val = '';\n  }\n};\n\n/**\n * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon\n * automatically calls registered compilers, this allows you to pass a visitor\n * function.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.visit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Object} returns the node after recursively visiting all child nodes.\n * @api public\n */\n\nutils.visit = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(fn), 'expected a visitor function');\n  fn(node);\n  return node.nodes ? utils.mapVisit(node, fn) : node;\n};\n\n/**\n * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by\n * [visit](#visit), use this method if you do not want `fn` to be called on\n * the first node.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.mapVisit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Object} `options`\n * @param {Function} `fn`\n * @return {Object} returns the node\n * @api public\n */\n\nutils.mapVisit = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isArray(node.nodes), 'expected node.nodes to be an array');\n  assert(isFunction(fn), 'expected a visitor function');\n  for (var i = 0; i < node.nodes.length; i++) {\n    utils.visit(node.nodes[i], fn);\n  }\n  return node;\n};\n\n/**\n * Unshift an `*.open` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^{/);\n *   if (match) {\n *     var parent = new Node({type: 'brace'});\n *     utils.addOpen(parent, Node);\n *     console.log(parent.nodes[0]):\n *     // { type: 'brace.open', val: '' };\n *\n *     // push the parent \"brace\" node onto the stack\n *     this.push(parent);\n *\n *     // return the parent node, so it's also added to the AST\n *     return brace;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created opening node.\n * @api public\n */\n\nutils.addOpen = function (node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n  if (typeof filter === 'function' && !filter(node)) return;\n  var open = new Node({\n    type: node.type + '.open',\n    val: val\n  });\n  var unshift = node.unshift || node.unshiftNode;\n  if (typeof unshift === 'function') {\n    unshift.call(node, open);\n  } else {\n    utils.unshiftNode(node, open);\n  }\n  return open;\n};\n\n/**\n * Push a `*.close` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^}/);\n *   if (match) {\n *     var parent = this.parent();\n *     if (parent.type !== 'brace') {\n *       throw new Error('missing opening: ' + '}');\n *     }\n *\n *     utils.addClose(parent, Node);\n *     console.log(parent.nodes[parent.nodes.length - 1]):\n *     // { type: 'brace.close', val: '' };\n *\n *     // no need to return a node, since the parent\n *     // was already added to the AST\n *     return;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created closing node.\n * @api public\n */\n\nutils.addClose = function (node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n  if (typeof filter === 'function' && !filter(node)) return;\n  var close = new Node({\n    type: node.type + '.close',\n    val: val\n  });\n  var push = node.push || node.pushNode;\n  if (typeof push === 'function') {\n    push.call(node, close);\n  } else {\n    utils.pushNode(node, close);\n  }\n  return close;\n};\n\n/**\n * Wraps the given `node` with `*.open` and `*.close` nodes.\n *\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the node\n * @api public\n */\n\nutils.wrapNodes = function (node, Node, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n  utils.addOpen(node, Node, filter);\n  utils.addClose(node, Node, filter);\n  return node;\n};\n\n/**\n * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.pushNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object} Returns the child node\n * @api public\n */\n\nutils.pushNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.push(node);\n  return node;\n};\n\n/**\n * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.unshiftNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {undefined}\n * @api public\n */\n\nutils.unshiftNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.unshift(node);\n};\n\n/**\n * Pop the last `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.popNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.popNode = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (typeof node.pop === 'function') {\n    return node.pop();\n  }\n  return node.nodes && node.nodes.pop();\n};\n\n/**\n * Shift the first `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.shiftNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.shiftNode = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (typeof node.shift === 'function') {\n    return node.shift();\n  }\n  return node.nodes && node.nodes.shift();\n};\n\n/**\n * Remove the specified `node` from `parent.nodes`.\n *\n * ```js\n * var parent = new Node({type: 'abc'});\n * var foo = new Node({type: 'foo'});\n * utils.pushNode(parent, foo);\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.removeNode(parent, foo);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.\n * @api public\n */\n\nutils.removeNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (!parent.nodes) {\n    return null;\n  }\n  if (typeof parent.remove === 'function') {\n    return parent.remove(node);\n  }\n  var idx = parent.nodes.indexOf(node);\n  if (idx !== -1) {\n    return parent.nodes.splice(idx, 1);\n  }\n};\n\n/**\n * Returns true if `node.type` matches the given `type`. Throws a\n * `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isType(node, 'foo')); // false\n * console.log(utils.isType(node, 'bar')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isType = function (node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  switch (typeOf(type)) {\n    case 'array':\n      var types = type.slice();\n      for (var i = 0; i < types.length; i++) {\n        if (utils.isType(node, types[i])) {\n          return true;\n        }\n      }\n      return false;\n    case 'string':\n      return node.type === type;\n    case 'regexp':\n      return type.test(node.type);\n    default:\n      {\n        throw new TypeError('expected \"type\" to be an array, string or regexp');\n      }\n  }\n};\n\n/**\n * Returns true if the given `node` has the given `type` in `node.nodes`.\n * Throws a `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'bar'}),\n *     new Node({type: 'baz'})\n *   ]\n * });\n * console.log(utils.hasType(node, 'xyz')); // false\n * console.log(utils.hasType(node, 'baz')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.hasType = function (node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (!Array.isArray(node.nodes)) return false;\n  for (var i = 0; i < node.nodes.length; i++) {\n    if (utils.isType(node.nodes[i], type)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns the first node from `node.nodes` of the given `type`\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var textNode = utils.firstOfType(node.nodes, 'text');\n * console.log(textNode.val);\n * //=> 'abc'\n * ```\n * @param {Array} `nodes`\n * @param {String} `type`\n * @return {Object|undefined} Returns the first matching node or undefined.\n * @api public\n */\n\nutils.firstOfType = function (nodes, type) {\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (utils.isType(node, type)) {\n      return node;\n    }\n  }\n};\n\n/**\n * Returns the node at the specified index, or the first node of the\n * given `type` from `node.nodes`.\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var nodeOne = utils.findNode(node.nodes, 'text');\n * console.log(nodeOne.val);\n * //=> 'abc'\n *\n * var nodeTwo = utils.findNode(node.nodes, 1);\n * console.log(nodeTwo.val);\n * //=> 'xyz'\n * ```\n *\n * @param {Array} `nodes`\n * @param {String|Number} `type` Node type or index.\n * @return {Object} Returns a node or undefined.\n * @api public\n */\n\nutils.findNode = function (nodes, type) {\n  if (!Array.isArray(nodes)) {\n    return null;\n  }\n  if (typeof type === 'number') {\n    return nodes[type];\n  }\n  return utils.firstOfType(nodes, type);\n};\n\n/**\n * Returns true if the given node is an \"*.open\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isOpen(brace)); // false\n * console.log(utils.isOpen(open)); // true\n * console.log(utils.isOpen(close)); // false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isOpen = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-5) === '.open';\n};\n\n/**\n * Returns true if the given node is a \"*.close\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isClose(brace)); // false\n * console.log(utils.isClose(open)); // false\n * console.log(utils.isClose(close)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isClose = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-6) === '.close';\n};\n\n/**\n * Returns true if `node.nodes` **has** an `.open` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.hasOpen(brace)); // false\n *\n * brace.pushNode(open);\n * console.log(utils.hasOpen(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpen = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var first = node.first || node.nodes ? node.nodes[0] : null;\n  if (utils.isNode(first)) {\n    return first.type === node.type + '.open';\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` **has** a `.close` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(close);\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasClose = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;\n  if (utils.isNode(last)) {\n    return last.type === node.type + '.close';\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` has both `.open` and `.close` nodes\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasOpen(brace)); // false\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(open);\n * brace.pushNode(close);\n * console.log(utils.hasOpen(brace)); // true\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpenAndClose = function (node) {\n  return utils.hasOpen(node) && utils.hasClose(node);\n};\n\n/**\n * Push the given `node` onto the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.addType = function (state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n  var type = node.parent ? node.parent.type : node.type.replace(/\\.open$/, '');\n  if (!state.hasOwnProperty('inside')) {\n    state.inside = {};\n  }\n  if (!state.inside.hasOwnProperty(type)) {\n    state.inside[type] = [];\n  }\n  var arr = state.inside[type];\n  arr.push(node);\n  return arr;\n};\n\n/**\n * Remove the given `node` from the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * utils.removeType(state, node);\n * //=> { brace: [] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.removeType = function (state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n  var type = node.parent ? node.parent.type : node.type.replace(/\\.close$/, '');\n  if (state.inside.hasOwnProperty(type)) {\n    return state.inside[type].pop();\n  }\n};\n\n/**\n * Returns true if `node.val` is an empty string, or `node.nodes` does\n * not contain any non-empty text nodes.\n *\n * ```js\n * var node = new Node({type: 'text'});\n * utils.isEmpty(node); //=> true\n * node.val = 'foo';\n * utils.isEmpty(node); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Boolean}\n * @api public\n */\n\nutils.isEmpty = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (!Array.isArray(node.nodes)) {\n    if (node.type !== 'text') {\n      return true;\n    }\n    if (typeof fn === 'function') {\n      return fn(node, node.parent);\n    }\n    return !utils.trim(node.val);\n  }\n  for (var i = 0; i < node.nodes.length; i++) {\n    var child = node.nodes[i];\n    if (utils.isOpen(child) || utils.isClose(child)) {\n      continue;\n    }\n    if (!utils.isEmpty(child, fn)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if the `state.inside` stack for the given type exists\n * and has one or more nodes on it.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * utils.addType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> true\n * utils.removeType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * ```\n * @param {Object} `state`\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isInsideType = function (state, type) {\n  assert(isObject(state), 'expected state to be an object');\n  assert(isString(type), 'expected type to be a string');\n  if (!state.hasOwnProperty('inside')) {\n    return false;\n  }\n  if (!state.inside.hasOwnProperty(type)) {\n    return false;\n  }\n  return state.inside[type].length > 0;\n};\n\n/**\n * Returns true if `node` is either a child or grand-child of the given `type`,\n * or `state.inside[type]` is a non-empty array.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.isInside(state, open, 'brace')); //=> false\n * utils.pushNode(node, open);\n * console.log(utils.isInside(state, open, 'brace')); //=> true\n * ```\n * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type` The `node.type` to check for.\n * @return {Boolean}\n * @api public\n */\n\nutils.isInside = function (state, node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n  if (Array.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      if (utils.isInside(state, node, type[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  var parent = node.parent;\n  if (typeof type === 'string') {\n    return parent && parent.type === type || utils.isInsideType(state, type);\n  }\n  if (typeOf(type) === 'regexp') {\n    if (parent && parent.type && type.test(parent.type)) {\n      return true;\n    }\n    var keys = Object.keys(state.inside);\n    var len = keys.length;\n    var idx = -1;\n    while (++idx < len) {\n      var key = keys[idx];\n      var val = state.inside[key];\n      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Get the last `n` element from the given `array`. Used for getting\n * a node from `node.nodes.`\n *\n * @param {Array} `array`\n * @param {Number} `n`\n * @return {undefined}\n * @api public\n */\n\nutils.last = function (arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Cast the given `val` to an array.\n *\n * ```js\n * console.log(utils.arrayify(''));\n * //=> []\n * console.log(utils.arrayify('foo'));\n * //=> ['foo']\n * console.log(utils.arrayify(['foo']));\n * //=> ['foo']\n * ```\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.arrayify = function (val) {\n  if (typeof val === 'string' && val !== '') {\n    return [val];\n  }\n  if (!Array.isArray(val)) {\n    return [];\n  }\n  return val;\n};\n\n/**\n * Convert the given `val` to a string by joining with `,`. Useful\n * for creating a cheerio/CSS/DOM-style selector from a list of strings.\n *\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.stringify = function (val) {\n  return utils.arrayify(val).join(',');\n};\n\n/**\n * Ensure that the given value is a string and call `.trim()` on it,\n * or return an empty string.\n *\n * @param {String} `str`\n * @return {String}\n * @api public\n */\n\nutils.trim = function (str) {\n  return typeof str === 'string' ? str.trim() : '';\n};\n\n/**\n * Return true if val is an object\n */\n\nfunction isObject(val) {\n  return typeOf(val) === 'object';\n}\n\n/**\n * Return true if val is a string\n */\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Return true if val is a function\n */\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\n/**\n * Return true if val is an array\n */\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Shim to ensure the `.append` methods work with any version of snapdragon\n */\n\nfunction append(compiler, val, node) {\n  if (typeof compiler.append !== 'function') {\n    return compiler.emit(val, node);\n  }\n  return compiler.append(val, node);\n}\n\n/**\n * Simplified assertion. Throws an error is `val` is falsey.\n */\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}","map":{"version":3,"names":["typeOf","require","utils","module","exports","isNode","node","noop","append","identity","val","toNoop","nodes","type","visit","fn","assert","isFunction","mapVisit","isArray","i","length","addOpen","Node","filter","open","unshift","unshiftNode","call","addClose","close","push","pushNode","wrapNodes","parent","define","popNode","pop","shiftNode","shift","removeNode","remove","idx","indexOf","splice","isType","types","slice","test","TypeError","hasType","Array","firstOfType","findNode","isOpen","isClose","hasOpen","first","hasClose","last","hasOpenAndClose","addType","state","isObject","replace","hasOwnProperty","inside","arr","removeType","isEmpty","trim","child","isInsideType","isString","isInside","keys","Object","len","key","n","arrayify","stringify","join","str","compiler","emit","message","Error"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/snapdragon-util/index.js"],"sourcesContent":["'use strict';\n\nvar typeOf = require('kind-of');\nvar utils = module.exports;\n\n/**\n * Returns true if the given value is a node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isNode(node)); //=> true\n * console.log(utils.isNode({})); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Boolean}\n * @api public\n */\n\nutils.isNode = function(node) {\n  return typeOf(node) === 'object' && node.isNode === true;\n};\n\n/**\n * Emit an empty string for the given `node`.\n *\n * ```js\n * // do nothing for beginning-of-string\n * snapdragon.compiler.set('bos', utils.noop);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.noop = function(node) {\n  append(this, '', node);\n};\n\n/**\n * Appdend `node.val` to `compiler.output`, exactly as it was created\n * by the parser.\n *\n * ```js\n * snapdragon.compiler.set('text', utils.identity);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.identity = function(node) {\n  append(this, node.val, node);\n};\n\n/**\n * Previously named `.emit`, this method appends the given `val`\n * to `compiler.output` for the given node. Useful when you know\n * what value should be appended advance, regardless of the actual\n * value of `node.val`.\n *\n * ```js\n * snapdragon.compiler\n *   .set('i', function(node) {\n *     this.mapVisit(node);\n *   })\n *   .set('i.open', utils.append('<i>'))\n *   .set('i.close', utils.append('</i>'))\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Function} Returns a compiler middleware function.\n * @api public\n */\n\nutils.append = function(val) {\n  return function(node) {\n    append(this, val, node);\n  };\n};\n\n/**\n * Used in compiler middleware, this onverts an AST node into\n * an empty `text` node and deletes `node.nodes` if it exists.\n * The advantage of this method is that, as opposed to completely\n * removing the node, indices will not need to be re-calculated\n * in sibling nodes, and nothing is appended to the output.\n *\n * ```js\n * utils.toNoop(node);\n * // convert `node.nodes` to the given value instead of deleting it\n * utils.toNoop(node, []);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.\n * @api public\n */\n\nutils.toNoop = function(node, nodes) {\n  if (nodes) {\n    node.nodes = nodes;\n  } else {\n    delete node.nodes;\n    node.type = 'text';\n    node.val = '';\n  }\n};\n\n/**\n * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon\n * automatically calls registered compilers, this allows you to pass a visitor\n * function.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.visit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Object} returns the node after recursively visiting all child nodes.\n * @api public\n */\n\nutils.visit = function(node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(fn), 'expected a visitor function');\n  fn(node);\n  return node.nodes ? utils.mapVisit(node, fn) : node;\n};\n\n/**\n * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by\n * [visit](#visit), use this method if you do not want `fn` to be called on\n * the first node.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.mapVisit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Object} `options`\n * @param {Function} `fn`\n * @return {Object} returns the node\n * @api public\n */\n\nutils.mapVisit = function(node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isArray(node.nodes), 'expected node.nodes to be an array');\n  assert(isFunction(fn), 'expected a visitor function');\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    utils.visit(node.nodes[i], fn);\n  }\n  return node;\n};\n\n/**\n * Unshift an `*.open` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^{/);\n *   if (match) {\n *     var parent = new Node({type: 'brace'});\n *     utils.addOpen(parent, Node);\n *     console.log(parent.nodes[0]):\n *     // { type: 'brace.open', val: '' };\n *\n *     // push the parent \"brace\" node onto the stack\n *     this.push(parent);\n *\n *     // return the parent node, so it's also added to the AST\n *     return brace;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created opening node.\n * @api public\n */\n\nutils.addOpen = function(node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var open = new Node({ type: node.type + '.open', val: val});\n  var unshift = node.unshift || node.unshiftNode;\n  if (typeof unshift === 'function') {\n    unshift.call(node, open);\n  } else {\n    utils.unshiftNode(node, open);\n  }\n  return open;\n};\n\n/**\n * Push a `*.close` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^}/);\n *   if (match) {\n *     var parent = this.parent();\n *     if (parent.type !== 'brace') {\n *       throw new Error('missing opening: ' + '}');\n *     }\n *\n *     utils.addClose(parent, Node);\n *     console.log(parent.nodes[parent.nodes.length - 1]):\n *     // { type: 'brace.close', val: '' };\n *\n *     // no need to return a node, since the parent\n *     // was already added to the AST\n *     return;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created closing node.\n * @api public\n */\n\nutils.addClose = function(node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var close = new Node({ type: node.type + '.close', val: val});\n  var push = node.push || node.pushNode;\n  if (typeof push === 'function') {\n    push.call(node, close);\n  } else {\n    utils.pushNode(node, close);\n  }\n  return close;\n};\n\n/**\n * Wraps the given `node` with `*.open` and `*.close` nodes.\n *\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the node\n * @api public\n */\n\nutils.wrapNodes = function(node, Node, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  utils.addOpen(node, Node, filter);\n  utils.addClose(node, Node, filter);\n  return node;\n};\n\n/**\n * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.pushNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object} Returns the child node\n * @api public\n */\n\nutils.pushNode = function(parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.push(node);\n  return node;\n};\n\n/**\n * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.unshiftNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {undefined}\n * @api public\n */\n\nutils.unshiftNode = function(parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.unshift(node);\n};\n\n/**\n * Pop the last `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.popNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.popNode = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (typeof node.pop === 'function') {\n    return node.pop();\n  }\n  return node.nodes && node.nodes.pop();\n};\n\n/**\n * Shift the first `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.shiftNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.shiftNode = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (typeof node.shift === 'function') {\n    return node.shift();\n  }\n  return node.nodes && node.nodes.shift();\n};\n\n/**\n * Remove the specified `node` from `parent.nodes`.\n *\n * ```js\n * var parent = new Node({type: 'abc'});\n * var foo = new Node({type: 'foo'});\n * utils.pushNode(parent, foo);\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.removeNode(parent, foo);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.\n * @api public\n */\n\nutils.removeNode = function(parent, node) {\n  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!parent.nodes) {\n    return null;\n  }\n\n  if (typeof parent.remove === 'function') {\n    return parent.remove(node);\n  }\n\n  var idx = parent.nodes.indexOf(node);\n  if (idx !== -1) {\n    return parent.nodes.splice(idx, 1);\n  }\n};\n\n/**\n * Returns true if `node.type` matches the given `type`. Throws a\n * `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isType(node, 'foo')); // false\n * console.log(utils.isType(node, 'bar')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isType = function(node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  switch (typeOf(type)) {\n    case 'array':\n      var types = type.slice();\n      for (var i = 0; i < types.length; i++) {\n        if (utils.isType(node, types[i])) {\n          return true;\n        }\n      }\n      return false;\n    case 'string':\n      return node.type === type;\n    case 'regexp':\n      return type.test(node.type);\n    default: {\n      throw new TypeError('expected \"type\" to be an array, string or regexp');\n    }\n  }\n};\n\n/**\n * Returns true if the given `node` has the given `type` in `node.nodes`.\n * Throws a `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'bar'}),\n *     new Node({type: 'baz'})\n *   ]\n * });\n * console.log(utils.hasType(node, 'xyz')); // false\n * console.log(utils.hasType(node, 'baz')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.hasType = function(node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (!Array.isArray(node.nodes)) return false;\n  for (var i = 0; i < node.nodes.length; i++) {\n    if (utils.isType(node.nodes[i], type)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns the first node from `node.nodes` of the given `type`\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var textNode = utils.firstOfType(node.nodes, 'text');\n * console.log(textNode.val);\n * //=> 'abc'\n * ```\n * @param {Array} `nodes`\n * @param {String} `type`\n * @return {Object|undefined} Returns the first matching node or undefined.\n * @api public\n */\n\nutils.firstOfType = function(nodes, type) {\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (utils.isType(node, type)) {\n      return node;\n    }\n  }\n};\n\n/**\n * Returns the node at the specified index, or the first node of the\n * given `type` from `node.nodes`.\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var nodeOne = utils.findNode(node.nodes, 'text');\n * console.log(nodeOne.val);\n * //=> 'abc'\n *\n * var nodeTwo = utils.findNode(node.nodes, 1);\n * console.log(nodeTwo.val);\n * //=> 'xyz'\n * ```\n *\n * @param {Array} `nodes`\n * @param {String|Number} `type` Node type or index.\n * @return {Object} Returns a node or undefined.\n * @api public\n */\n\nutils.findNode = function(nodes, type) {\n  if (!Array.isArray(nodes)) {\n    return null;\n  }\n  if (typeof type === 'number') {\n    return nodes[type];\n  }\n  return utils.firstOfType(nodes, type);\n};\n\n/**\n * Returns true if the given node is an \"*.open\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isOpen(brace)); // false\n * console.log(utils.isOpen(open)); // true\n * console.log(utils.isOpen(close)); // false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isOpen = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-5) === '.open';\n};\n\n/**\n * Returns true if the given node is a \"*.close\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isClose(brace)); // false\n * console.log(utils.isClose(open)); // false\n * console.log(utils.isClose(close)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isClose = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-6) === '.close';\n};\n\n/**\n * Returns true if `node.nodes` **has** an `.open` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.hasOpen(brace)); // false\n *\n * brace.pushNode(open);\n * console.log(utils.hasOpen(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpen = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var first = node.first || node.nodes ? node.nodes[0] : null;\n  if (utils.isNode(first)) {\n    return first.type === node.type + '.open';\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` **has** a `.close` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(close);\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasClose = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;\n  if (utils.isNode(last)) {\n    return last.type === node.type + '.close';\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` has both `.open` and `.close` nodes\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasOpen(brace)); // false\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(open);\n * brace.pushNode(close);\n * console.log(utils.hasOpen(brace)); // true\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpenAndClose = function(node) {\n  return utils.hasOpen(node) && utils.hasClose(node);\n};\n\n/**\n * Push the given `node` onto the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.addType = function(state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  var type = node.parent\n    ? node.parent.type\n    : node.type.replace(/\\.open$/, '');\n\n  if (!state.hasOwnProperty('inside')) {\n    state.inside = {};\n  }\n  if (!state.inside.hasOwnProperty(type)) {\n    state.inside[type] = [];\n  }\n\n  var arr = state.inside[type];\n  arr.push(node);\n  return arr;\n};\n\n/**\n * Remove the given `node` from the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * utils.removeType(state, node);\n * //=> { brace: [] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.removeType = function(state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  var type = node.parent\n    ? node.parent.type\n    : node.type.replace(/\\.close$/, '');\n\n  if (state.inside.hasOwnProperty(type)) {\n    return state.inside[type].pop();\n  }\n};\n\n/**\n * Returns true if `node.val` is an empty string, or `node.nodes` does\n * not contain any non-empty text nodes.\n *\n * ```js\n * var node = new Node({type: 'text'});\n * utils.isEmpty(node); //=> true\n * node.val = 'foo';\n * utils.isEmpty(node); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Boolean}\n * @api public\n */\n\nutils.isEmpty = function(node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!Array.isArray(node.nodes)) {\n    if (node.type !== 'text') {\n      return true;\n    }\n    if (typeof fn === 'function') {\n      return fn(node, node.parent);\n    }\n    return !utils.trim(node.val);\n  }\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    var child = node.nodes[i];\n    if (utils.isOpen(child) || utils.isClose(child)) {\n      continue;\n    }\n    if (!utils.isEmpty(child, fn)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns true if the `state.inside` stack for the given type exists\n * and has one or more nodes on it.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * utils.addType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> true\n * utils.removeType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * ```\n * @param {Object} `state`\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isInsideType = function(state, type) {\n  assert(isObject(state), 'expected state to be an object');\n  assert(isString(type), 'expected type to be a string');\n\n  if (!state.hasOwnProperty('inside')) {\n    return false;\n  }\n\n  if (!state.inside.hasOwnProperty(type)) {\n    return false;\n  }\n\n  return state.inside[type].length > 0;\n};\n\n/**\n * Returns true if `node` is either a child or grand-child of the given `type`,\n * or `state.inside[type]` is a non-empty array.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.isInside(state, open, 'brace')); //=> false\n * utils.pushNode(node, open);\n * console.log(utils.isInside(state, open, 'brace')); //=> true\n * ```\n * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type` The `node.type` to check for.\n * @return {Boolean}\n * @api public\n */\n\nutils.isInside = function(state, node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  if (Array.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      if (utils.isInside(state, node, type[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var parent = node.parent;\n  if (typeof type === 'string') {\n    return (parent && parent.type === type) || utils.isInsideType(state, type);\n  }\n\n  if (typeOf(type) === 'regexp') {\n    if (parent && parent.type && type.test(parent.type)) {\n      return true;\n    }\n\n    var keys = Object.keys(state.inside);\n    var len = keys.length;\n    var idx = -1;\n    while (++idx < len) {\n      var key = keys[idx];\n      var val = state.inside[key];\n\n      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Get the last `n` element from the given `array`. Used for getting\n * a node from `node.nodes.`\n *\n * @param {Array} `array`\n * @param {Number} `n`\n * @return {undefined}\n * @api public\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Cast the given `val` to an array.\n *\n * ```js\n * console.log(utils.arrayify(''));\n * //=> []\n * console.log(utils.arrayify('foo'));\n * //=> ['foo']\n * console.log(utils.arrayify(['foo']));\n * //=> ['foo']\n * ```\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === 'string' && val !== '') {\n    return [val];\n  }\n  if (!Array.isArray(val)) {\n    return [];\n  }\n  return val;\n};\n\n/**\n * Convert the given `val` to a string by joining with `,`. Useful\n * for creating a cheerio/CSS/DOM-style selector from a list of strings.\n *\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.stringify = function(val) {\n  return utils.arrayify(val).join(',');\n};\n\n/**\n * Ensure that the given value is a string and call `.trim()` on it,\n * or return an empty string.\n *\n * @param {String} `str`\n * @return {String}\n * @api public\n */\n\nutils.trim = function(str) {\n  return typeof str === 'string' ? str.trim() : '';\n};\n\n/**\n * Return true if val is an object\n */\n\nfunction isObject(val) {\n  return typeOf(val) === 'object';\n}\n\n/**\n * Return true if val is a string\n */\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Return true if val is a function\n */\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\n/**\n * Return true if val is an array\n */\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Shim to ensure the `.append` methods work with any version of snapdragon\n */\n\nfunction append(compiler, val, node) {\n  if (typeof compiler.append !== 'function') {\n    return compiler.emit(val, node);\n  }\n  return compiler.append(val, node);\n}\n\n/**\n * Simplified assertion. Throws an error is `val` is falsey.\n */\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}