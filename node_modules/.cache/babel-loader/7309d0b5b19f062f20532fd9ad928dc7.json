{"ast":null,"code":"'use strict';\n\nvar os = require('os');\nvar path = require('path');\nvar through = require('through2');\nvar fo = require('../file-operations');\nvar isWindows = os.platform() === 'win32';\nfunction linkStream(optResolver) {\n  function linkFile(file, enc, callback) {\n    var isRelative = optResolver.resolve('relativeSymlinks', file);\n    var flags = fo.getFlags({\n      overwrite: optResolver.resolve('overwrite', file),\n      append: false\n    });\n    if (!isWindows) {\n      // On non-Windows, just use 'file'\n      return createLinkWithType('file');\n    }\n    fo.reflectStat(file.symlink, file, onReflectTarget);\n    function onReflectTarget(statErr) {\n      if (statErr && statErr.code !== 'ENOENT') {\n        return callback(statErr);\n      }\n      // If target doesn't exist, the vinyl will still carry the target stats.\n      // Let's use those to determine which kind of dangling link to create.\n\n      // This option provides a way to create a Junction instead of a\n      // Directory symlink on Windows. This comes with the following caveats:\n      // * NTFS Junctions cannot be relative.\n      // * NTFS Junctions MUST be directories.\n      // * NTFS Junctions must be on the same file system.\n      // * Most products CANNOT detect a directory is a Junction:\n      //    This has the side effect of possibly having a whole directory\n      //    deleted when a product is deleting the Junction directory.\n      //    For example, JetBrains product lines will delete the entire contents\n      //    of the TARGET directory because the product does not realize it's\n      //    a symlink as the JVM and Node return false for isSymlink.\n\n      // This function is Windows only, so we don't need to check again\n      var useJunctions = optResolver.resolve('useJunctions', file);\n      var dirType = useJunctions ? 'junction' : 'dir';\n      var type = !statErr && file.isDirectory() ? dirType : 'file';\n      createLinkWithType(type);\n    }\n    function createLinkWithType(type) {\n      // This is done after prepare() to use the adjusted file.base property\n      if (isRelative && type !== 'junction') {\n        file.symlink = path.relative(file.base, file.symlink);\n      }\n      var opts = {\n        flags: flags,\n        type: type\n      };\n      fo.symlink(file.symlink, file.path, opts, onSymlink);\n    }\n    function onSymlink(symlinkErr) {\n      if (symlinkErr) {\n        return callback(symlinkErr);\n      }\n      fo.reflectLinkStat(file.path, file, onReflectLink);\n    }\n    function onReflectLink(reflectErr) {\n      if (reflectErr) {\n        return callback(reflectErr);\n      }\n      callback(null, file);\n    }\n  }\n  return through.obj(linkFile);\n}\nmodule.exports = linkStream;","map":{"version":3,"names":["os","require","path","through","fo","isWindows","platform","linkStream","optResolver","linkFile","file","enc","callback","isRelative","resolve","flags","getFlags","overwrite","append","createLinkWithType","reflectStat","symlink","onReflectTarget","statErr","code","useJunctions","dirType","type","isDirectory","relative","base","opts","onSymlink","symlinkErr","reflectLinkStat","onReflectLink","reflectErr","obj","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/vinyl-fs/lib/symlink/link-file.js"],"sourcesContent":["'use strict';\n\nvar os = require('os');\nvar path = require('path');\n\nvar through = require('through2');\n\nvar fo = require('../file-operations');\n\nvar isWindows = (os.platform() === 'win32');\n\nfunction linkStream(optResolver) {\n\n  function linkFile(file, enc, callback) {\n    var isRelative = optResolver.resolve('relativeSymlinks', file);\n    var flags = fo.getFlags({\n      overwrite: optResolver.resolve('overwrite', file),\n      append: false,\n    });\n\n    if (!isWindows) {\n      // On non-Windows, just use 'file'\n      return createLinkWithType('file');\n    }\n\n    fo.reflectStat(file.symlink, file, onReflectTarget);\n\n    function onReflectTarget(statErr) {\n      if (statErr && statErr.code !== 'ENOENT') {\n        return callback(statErr);\n      }\n      // If target doesn't exist, the vinyl will still carry the target stats.\n      // Let's use those to determine which kind of dangling link to create.\n\n      // This option provides a way to create a Junction instead of a\n      // Directory symlink on Windows. This comes with the following caveats:\n      // * NTFS Junctions cannot be relative.\n      // * NTFS Junctions MUST be directories.\n      // * NTFS Junctions must be on the same file system.\n      // * Most products CANNOT detect a directory is a Junction:\n      //    This has the side effect of possibly having a whole directory\n      //    deleted when a product is deleting the Junction directory.\n      //    For example, JetBrains product lines will delete the entire contents\n      //    of the TARGET directory because the product does not realize it's\n      //    a symlink as the JVM and Node return false for isSymlink.\n\n      // This function is Windows only, so we don't need to check again\n      var useJunctions = optResolver.resolve('useJunctions', file);\n\n      var dirType = useJunctions ? 'junction' : 'dir';\n      var type = !statErr && file.isDirectory() ? dirType : 'file';\n\n      createLinkWithType(type);\n    }\n\n    function createLinkWithType(type) {\n      // This is done after prepare() to use the adjusted file.base property\n      if (isRelative && type !== 'junction') {\n        file.symlink = path.relative(file.base, file.symlink);\n      }\n\n      var opts = {\n        flags: flags,\n        type: type,\n      };\n      fo.symlink(file.symlink, file.path, opts, onSymlink);\n    }\n\n    function onSymlink(symlinkErr) {\n      if (symlinkErr) {\n        return callback(symlinkErr);\n      }\n\n      fo.reflectLinkStat(file.path, file, onReflectLink);\n    }\n\n    function onReflectLink(reflectErr) {\n      if (reflectErr) {\n        return callback(reflectErr);\n      }\n\n      callback(null, file);\n    }\n  }\n\n  return through.obj(linkFile);\n}\n\nmodule.exports = linkStream;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACtB,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAE1B,IAAIE,OAAO,GAAGF,OAAO,CAAC,UAAU,CAAC;AAEjC,IAAIG,EAAE,GAAGH,OAAO,CAAC,oBAAoB,CAAC;AAEtC,IAAII,SAAS,GAAIL,EAAE,CAACM,QAAQ,EAAE,KAAK,OAAQ;AAE3C,SAASC,UAAU,CAACC,WAAW,EAAE;EAE/B,SAASC,QAAQ,CAACC,IAAI,EAAEC,GAAG,EAAEC,QAAQ,EAAE;IACrC,IAAIC,UAAU,GAAGL,WAAW,CAACM,OAAO,CAAC,kBAAkB,EAAEJ,IAAI,CAAC;IAC9D,IAAIK,KAAK,GAAGX,EAAE,CAACY,QAAQ,CAAC;MACtBC,SAAS,EAAET,WAAW,CAACM,OAAO,CAAC,WAAW,EAAEJ,IAAI,CAAC;MACjDQ,MAAM,EAAE;IACV,CAAC,CAAC;IAEF,IAAI,CAACb,SAAS,EAAE;MACd;MACA,OAAOc,kBAAkB,CAAC,MAAM,CAAC;IACnC;IAEAf,EAAE,CAACgB,WAAW,CAACV,IAAI,CAACW,OAAO,EAAEX,IAAI,EAAEY,eAAe,CAAC;IAEnD,SAASA,eAAe,CAACC,OAAO,EAAE;MAChC,IAAIA,OAAO,IAAIA,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE;QACxC,OAAOZ,QAAQ,CAACW,OAAO,CAAC;MAC1B;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MAEA;MACA,IAAIE,YAAY,GAAGjB,WAAW,CAACM,OAAO,CAAC,cAAc,EAAEJ,IAAI,CAAC;MAE5D,IAAIgB,OAAO,GAAGD,YAAY,GAAG,UAAU,GAAG,KAAK;MAC/C,IAAIE,IAAI,GAAG,CAACJ,OAAO,IAAIb,IAAI,CAACkB,WAAW,EAAE,GAAGF,OAAO,GAAG,MAAM;MAE5DP,kBAAkB,CAACQ,IAAI,CAAC;IAC1B;IAEA,SAASR,kBAAkB,CAACQ,IAAI,EAAE;MAChC;MACA,IAAId,UAAU,IAAIc,IAAI,KAAK,UAAU,EAAE;QACrCjB,IAAI,CAACW,OAAO,GAAGnB,IAAI,CAAC2B,QAAQ,CAACnB,IAAI,CAACoB,IAAI,EAAEpB,IAAI,CAACW,OAAO,CAAC;MACvD;MAEA,IAAIU,IAAI,GAAG;QACThB,KAAK,EAAEA,KAAK;QACZY,IAAI,EAAEA;MACR,CAAC;MACDvB,EAAE,CAACiB,OAAO,CAACX,IAAI,CAACW,OAAO,EAAEX,IAAI,CAACR,IAAI,EAAE6B,IAAI,EAAEC,SAAS,CAAC;IACtD;IAEA,SAASA,SAAS,CAACC,UAAU,EAAE;MAC7B,IAAIA,UAAU,EAAE;QACd,OAAOrB,QAAQ,CAACqB,UAAU,CAAC;MAC7B;MAEA7B,EAAE,CAAC8B,eAAe,CAACxB,IAAI,CAACR,IAAI,EAAEQ,IAAI,EAAEyB,aAAa,CAAC;IACpD;IAEA,SAASA,aAAa,CAACC,UAAU,EAAE;MACjC,IAAIA,UAAU,EAAE;QACd,OAAOxB,QAAQ,CAACwB,UAAU,CAAC;MAC7B;MAEAxB,QAAQ,CAAC,IAAI,EAAEF,IAAI,CAAC;IACtB;EACF;EAEA,OAAOP,OAAO,CAACkC,GAAG,CAAC5B,QAAQ,CAAC;AAC9B;AAEA6B,MAAM,CAACC,OAAO,GAAGhC,UAAU"},"metadata":{},"sourceType":"script"}