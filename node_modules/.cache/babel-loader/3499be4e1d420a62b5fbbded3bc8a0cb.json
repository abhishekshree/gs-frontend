{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar fsevents;\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\n// fsevents instance helper functions\n\n// object to hold per-process fsevents instances\n// (may be shared across chokidar FSWatcher instances)\nvar FSEventsWatchers = Object.create(null);\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nvar consolidateThreshhold = 10;\n\n// Private function: Instantiates the fsevents interface\n\n// * path       - string, path to be watched\n// * callback   - function, called when fsevents is bound and ready\n\n// Returns new fsevents instance\nfunction createFSEventsInstance(path, callback) {\n  return new fsevents(path).on('fsevent', callback).start();\n}\n\n// Private function: Instantiates the fsevents interface or binds listeners\n// to an existing one covering the same file tree\n\n// * path       - string, path to be watched\n// * realPath   - string, real path (in case of symlinks)\n// * listener   - function, called when fsevents emits events\n// * rawEmitter - function, passes data to listeners of the 'raw' event\n\n// Returns close function\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  var watchContainer;\n  var parentPath = sysPath.dirname(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n  function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  }\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  function watchedParent() {\n    return Object.keys(FSEventsWatchers).some(function (watchedPath) {\n      // condition is met when indexOf returns 0\n      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {\n        watchPath = watchedPath;\n        return true;\n      }\n    });\n  }\n  if (watchPath in FSEventsWatchers || watchedParent()) {\n    watchContainer = FSEventsWatchers[watchPath];\n    watchContainer.listeners.push(filteredListener);\n  } else {\n    watchContainer = FSEventsWatchers[watchPath] = {\n      listeners: [filteredListener],\n      rawEmitters: [rawEmitter],\n      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {\n        var info = fsevents.getInfo(fullPath, flags);\n        watchContainer.listeners.forEach(function (listener) {\n          listener(fullPath, flags, info);\n        });\n        watchContainer.rawEmitters.forEach(function (emitter) {\n          emitter(info.event, fullPath, info);\n        });\n      })\n    };\n  }\n  var listenerIndex = watchContainer.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return function close() {\n    delete watchContainer.listeners[listenerIndex];\n    delete watchContainer.rawEmitters[listenerIndex];\n    if (!Object.keys(watchContainer.listeners).length) {\n      watchContainer.watcher.stop();\n      delete FSEventsWatchers[watchPath];\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nfunction couldConsolidate(path) {\n  var keys = Object.keys(FSEventsWatchers);\n  var count = 0;\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var watchPath = keys[i];\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isConstructor(obj) {\n  return obj.prototype !== undefined && obj.prototype.constructor !== undefined;\n}\n\n// returns boolean indicating whether fsevents can be used\nfunction canUse() {\n  return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);\n}\n\n// determines subdirectory traversal levels from root to path\nfunction depth(path, root) {\n  var i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n}\n\n// fake constructor for attaching fsevents-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction FsEventsHandler() {}\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * watchPath  - string, file/dir path to be watched with fsevents\n// * realPath   - string, real path (in case of symlinks)\n// * transform  - function, path transformer\n// * globFilter - function, path filter in case a glob pattern was provided\n\n// Returns close function for the watcher instance\nFsEventsHandler.prototype._watchWithFsEvents = function (watchPath, realPath, transform, globFilter) {\n  if (this._isIgnored(watchPath)) return;\n  var watchCallback = function (fullPath, flags, info) {\n    if (this.options.depth !== undefined && depth(fullPath, realPath) > this.options.depth) return;\n    var path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    var parent = sysPath.dirname(path);\n    var item = sysPath.basename(path);\n    var watchedDir = this._getWatchedDir(info.type === 'directory' ? path : parent);\n    var checkIgnored = function (stats) {\n      if (this._isIgnored(path, stats)) {\n        this._ignoredPaths[path] = true;\n        if (stats && stats.isDirectory()) {\n          this._ignoredPaths[path + '/**/*'] = true;\n        }\n        return true;\n      } else {\n        delete this._ignoredPaths[path];\n        delete this._ignoredPaths[path + '/**/*'];\n      }\n    }.bind(this);\n    var handleEvent = function (event) {\n      if (checkIgnored()) return;\n      if (event === 'unlink') {\n        // suppress unlink events on never before seen files\n        if (info.type === 'directory' || watchedDir.has(item)) {\n          this._remove(parent, item);\n        }\n      } else {\n        if (event === 'add') {\n          // track new directories\n          if (info.type === 'directory') this._getWatchedDir(path);\n          if (info.type === 'symlink' && this.options.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = this.options.depth === undefined ? undefined : depth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } else {\n            // track new paths\n            // (other than symlinks being followed, which will be tracked soon)\n            this._getWatchedDir(parent).add(item);\n          }\n        }\n        var eventName = info.type === 'directory' ? event + 'Dir' : event;\n        this._emit(eventName, path);\n        if (eventName === 'addDir') this._addToFsEvents(path, false, true);\n      }\n    }.bind(this);\n    function addOrChange() {\n      handleEvent(watchedDir.has(item) ? 'change' : 'add');\n    }\n    function checkFd() {\n      fs.open(path, 'r', function (error, fd) {\n        if (error) {\n          error.code !== 'EACCES' ? handleEvent('unlink') : addOrChange();\n        } else {\n          fs.close(fd, function (err) {\n            err && err.code !== 'EACCES' ? handleEvent('unlink') : addOrChange();\n          });\n        }\n      });\n    }\n    // correct for wrong events emitted\n    var wrongEventFlags = [69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912];\n    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {\n      if (typeof this.options.ignored === 'function') {\n        fs.stat(path, function (error, stats) {\n          if (checkIgnored(stats)) return;\n          stats ? addOrChange() : handleEvent('unlink');\n        });\n      } else {\n        checkFd();\n      }\n    } else {\n      switch (info.event) {\n        case 'created':\n        case 'modified':\n          return addOrChange();\n        case 'deleted':\n        case 'moved':\n          return checkFd();\n      }\n    }\n  }.bind(this);\n  var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.emit.bind(this, 'raw'));\n  this._emitReady();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * linkPath   - string, path to symlink\n// * fullPath   - string, absolute path to the symlink\n// * transform  - function, pre-existing path transformer\n// * curDepth   - int, level of subdirectories traversed to where symlink is\n\n// Returns nothing\nFsEventsHandler.prototype._handleFsEventsSymlink = function (linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[fullPath]) return;else this._symlinkPaths[fullPath] = true;\n  this._readyCount++;\n  fs.realpath(linkPath, function (error, linkTarget) {\n    if (this._handleError(error) || this._isIgnored(linkTarget)) {\n      return this._emitReady();\n    }\n    this._readyCount++;\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, function (path) {\n      var dotSlash = '.' + sysPath.sep;\n      var aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== dotSlash) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== dotSlash) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  }.bind(this));\n};\n\n// Private method: Handle added path with fsevents\n\n// * path       - string, file/directory path or glob pattern\n// * transform  - function, converts working path to what the user expects\n// * forceAdd   - boolean, ensure add is emitted\n// * priorDepth - int, level of subdirectories already traversed\n\n// Returns nothing\nFsEventsHandler.prototype._addToFsEvents = function (path, transform, forceAdd, priorDepth) {\n  // applies transform if provided, otherwise returns same value\n  var processPath = typeof transform === 'function' ? transform : function (val) {\n    return val;\n  };\n  var emitAdd = function (newPath, stats) {\n    var pp = processPath(newPath);\n    var isDir = stats.isDirectory();\n    var dirObj = this._getWatchedDir(sysPath.dirname(pp));\n    var base = sysPath.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n    if (!this.options.ignoreInitial || forceAdd === true) {\n      this._emit(isDir ? 'addDir' : 'add', pp, stats);\n    }\n  }.bind(this);\n  var wh = this._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function (error, stats) {\n    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {\n      this._emitReady();\n      return this._emitReady();\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) emitAdd(processPath(path), stats);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > this.options.depth) return;\n\n      // scan the contents of the dir\n      readdirp({\n        root: wh.watchPath,\n        entryType: 'all',\n        fileFilter: wh.filterPath,\n        directoryFilter: wh.filterDir,\n        lstat: true,\n        depth: this.options.depth - (priorDepth || 0)\n      }).on('data', function (entry) {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;\n        var joinedPath = sysPath.join(wh.watchPath, entry.path);\n        var fullPath = entry.fullPath;\n        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          var curDepth = this.options.depth === undefined ? undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          emitAdd(joinedPath, entry.stat);\n        }\n      }.bind(this)).on('error', function () {\n        // Ignore readdirp errors\n      }).on('end', this._emitReady);\n    } else {\n      emitAdd(wh.watchPath, stats);\n      this._emitReady();\n    }\n  }.bind(this));\n  if (this.options.persistent && forceAdd !== true) {\n    var initWatch = function (error, realPath) {\n      if (this.closed) return;\n      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n      if (closer) {\n        this._closers[path] = this._closers[path] || [];\n        this._closers[path].push(closer);\n      }\n    }.bind(this);\n    if (typeof transform === 'function') {\n      // realpath has already been resolved\n      initWatch();\n    } else {\n      fs.realpath(wh.watchPath, initWatch);\n    }\n  }\n};\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":{"version":3,"names":["fs","require","sysPath","readdirp","fsevents","error","process","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","FSEventsWatchers","Object","create","consolidateThreshhold","createFSEventsInstance","path","callback","on","start","setFSEventsListener","realPath","listener","rawEmitter","watchPath","extname","dirname","watchContainer","parentPath","couldConsolidate","resolvedPath","resolve","hasSymlink","filteredListener","fullPath","flags","info","replace","indexOf","sep","watchedParent","keys","some","watchedPath","listeners","push","rawEmitters","watcher","getInfo","forEach","emitter","event","listenerIndex","length","close","stop","count","i","len","isConstructor","obj","prototype","undefined","constructor","canUse","depth","root","FsEventsHandler","_watchWithFsEvents","transform","globFilter","_isIgnored","watchCallback","options","join","relative","parent","item","basename","watchedDir","_getWatchedDir","type","checkIgnored","stats","_ignoredPaths","isDirectory","bind","handleEvent","has","_remove","followSymlinks","curDepth","_addToFsEvents","add","eventName","_emit","addOrChange","checkFd","open","fd","code","err","wrongEventFlags","ignored","stat","closer","emit","_emitReady","_handleFsEventsSymlink","linkPath","_symlinkPaths","_readyCount","realpath","linkTarget","_handleError","dotSlash","aliasedPath","forceAdd","priorDepth","processPath","val","emitAdd","newPath","pp","isDir","dirObj","base","ignoreInitial","wh","_getWatchHelpers","statMethod","entryType","fileFilter","filterPath","directoryFilter","filterDir","lstat","entry","joinedPath","isSymbolicLink","persistent","initWatch","closed","_closers","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/chokidar/lib/fsevents-handler.js"],"sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar fsevents;\ntry { fsevents = require('fsevents'); } catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error)\n}\n\n// fsevents instance helper functions\n\n// object to hold per-process fsevents instances\n// (may be shared across chokidar FSWatcher instances)\nvar FSEventsWatchers = Object.create(null);\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nvar consolidateThreshhold = 10;\n\n// Private function: Instantiates the fsevents interface\n\n// * path       - string, path to be watched\n// * callback   - function, called when fsevents is bound and ready\n\n// Returns new fsevents instance\nfunction createFSEventsInstance(path, callback) {\n  return (new fsevents(path)).on('fsevent', callback).start();\n}\n\n// Private function: Instantiates the fsevents interface or binds listeners\n// to an existing one covering the same file tree\n\n// * path       - string, path to be watched\n// * realPath   - string, real path (in case of symlinks)\n// * listener   - function, called when fsevents emits events\n// * rawEmitter - function, passes data to listeners of the 'raw' event\n\n// Returns close function\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  var watchContainer;\n  var parentPath = sysPath.dirname(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n  function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  }\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  function watchedParent() {\n    return Object.keys(FSEventsWatchers).some(function(watchedPath) {\n      // condition is met when indexOf returns 0\n      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {\n        watchPath = watchedPath;\n        return true;\n      }\n    });\n  }\n\n  if (watchPath in FSEventsWatchers || watchedParent()) {\n    watchContainer = FSEventsWatchers[watchPath];\n    watchContainer.listeners.push(filteredListener);\n  } else {\n    watchContainer = FSEventsWatchers[watchPath] = {\n      listeners: [filteredListener],\n      rawEmitters: [rawEmitter],\n      watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {\n        var info = fsevents.getInfo(fullPath, flags);\n        watchContainer.listeners.forEach(function(listener) {\n          listener(fullPath, flags, info);\n        });\n        watchContainer.rawEmitters.forEach(function(emitter) {\n          emitter(info.event, fullPath, info);\n        });\n      })\n    };\n  }\n  var listenerIndex = watchContainer.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return function close() {\n    delete watchContainer.listeners[listenerIndex];\n    delete watchContainer.rawEmitters[listenerIndex];\n    if (!Object.keys(watchContainer.listeners).length) {\n      watchContainer.watcher.stop();\n      delete FSEventsWatchers[watchPath];\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nfunction couldConsolidate(path) {\n  var keys = Object.keys(FSEventsWatchers);\n  var count = 0;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var watchPath = keys[i];\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isConstructor(obj) {\n  return obj.prototype !== undefined && obj.prototype.constructor !== undefined;\n}\n\n// returns boolean indicating whether fsevents can be used\nfunction canUse() {\n  return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);\n}\n\n// determines subdirectory traversal levels from root to path\nfunction depth(path, root) {\n  var i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n}\n\n// fake constructor for attaching fsevents-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction FsEventsHandler() {}\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * watchPath  - string, file/dir path to be watched with fsevents\n// * realPath   - string, real path (in case of symlinks)\n// * transform  - function, path transformer\n// * globFilter - function, path filter in case a glob pattern was provided\n\n// Returns close function for the watcher instance\nFsEventsHandler.prototype._watchWithFsEvents =\nfunction(watchPath, realPath, transform, globFilter) {\n  if (this._isIgnored(watchPath)) return;\n  var watchCallback = function(fullPath, flags, info) {\n    if (\n      this.options.depth !== undefined &&\n      depth(fullPath, realPath) > this.options.depth\n    ) return;\n    var path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    var parent = sysPath.dirname(path);\n    var item = sysPath.basename(path);\n    var watchedDir = this._getWatchedDir(\n      info.type === 'directory' ? path : parent\n    );\n    var checkIgnored = function(stats) {\n      if (this._isIgnored(path, stats)) {\n        this._ignoredPaths[path] = true;\n        if (stats && stats.isDirectory()) {\n          this._ignoredPaths[path + '/**/*'] = true;\n        }\n        return true;\n      } else {\n        delete this._ignoredPaths[path];\n        delete this._ignoredPaths[path + '/**/*'];\n      }\n    }.bind(this);\n\n    var handleEvent = function(event) {\n      if (checkIgnored()) return;\n\n      if (event === 'unlink') {\n        // suppress unlink events on never before seen files\n        if (info.type === 'directory' || watchedDir.has(item)) {\n          this._remove(parent, item);\n        }\n      } else {\n        if (event === 'add') {\n          // track new directories\n          if (info.type === 'directory') this._getWatchedDir(path);\n\n          if (info.type === 'symlink' && this.options.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = this.options.depth === undefined ?\n              undefined : depth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } else {\n            // track new paths\n            // (other than symlinks being followed, which will be tracked soon)\n            this._getWatchedDir(parent).add(item);\n          }\n        }\n        var eventName = info.type === 'directory' ? event + 'Dir' : event;\n        this._emit(eventName, path);\n        if (eventName === 'addDir') this._addToFsEvents(path, false, true);\n      }\n    }.bind(this);\n\n    function addOrChange() {\n      handleEvent(watchedDir.has(item) ? 'change' : 'add');\n    }\n    function checkFd() {\n      fs.open(path, 'r', function(error, fd) {\n        if (error) {\n          error.code !== 'EACCES' ?\n            handleEvent('unlink') : addOrChange();\n        } else {\n          fs.close(fd, function(err) {\n            err && err.code !== 'EACCES' ?\n              handleEvent('unlink') : addOrChange();\n          });\n        }\n      });\n    }\n    // correct for wrong events emitted\n    var wrongEventFlags = [\n      69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n    ];\n    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {\n      if (typeof this.options.ignored === 'function') {\n        fs.stat(path, function(error, stats) {\n          if (checkIgnored(stats)) return;\n          stats ? addOrChange() : handleEvent('unlink');\n        });\n      } else {\n        checkFd();\n      }\n    } else {\n      switch (info.event) {\n      case 'created':\n      case 'modified':\n        return addOrChange();\n      case 'deleted':\n      case 'moved':\n        return checkFd();\n      }\n    }\n  }.bind(this);\n\n  var closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.emit.bind(this, 'raw')\n  );\n\n  this._emitReady();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * linkPath   - string, path to symlink\n// * fullPath   - string, absolute path to the symlink\n// * transform  - function, pre-existing path transformer\n// * curDepth   - int, level of subdirectories traversed to where symlink is\n\n// Returns nothing\nFsEventsHandler.prototype._handleFsEventsSymlink =\nfunction(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[fullPath]) return;\n  else this._symlinkPaths[fullPath] = true;\n\n  this._readyCount++;\n\n  fs.realpath(linkPath, function(error, linkTarget) {\n    if (this._handleError(error) || this._isIgnored(linkTarget)) {\n      return this._emitReady();\n    }\n\n    this._readyCount++;\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, function(path) {\n      var dotSlash = '.' + sysPath.sep;\n      var aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== dotSlash) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== dotSlash) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  }.bind(this));\n};\n\n// Private method: Handle added path with fsevents\n\n// * path       - string, file/directory path or glob pattern\n// * transform  - function, converts working path to what the user expects\n// * forceAdd   - boolean, ensure add is emitted\n// * priorDepth - int, level of subdirectories already traversed\n\n// Returns nothing\nFsEventsHandler.prototype._addToFsEvents =\nfunction(path, transform, forceAdd, priorDepth) {\n\n  // applies transform if provided, otherwise returns same value\n  var processPath = typeof transform === 'function' ?\n    transform : function(val) { return val; };\n\n  var emitAdd = function(newPath, stats) {\n    var pp = processPath(newPath);\n    var isDir = stats.isDirectory();\n    var dirObj = this._getWatchedDir(sysPath.dirname(pp));\n    var base = sysPath.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this._getWatchedDir(pp);\n\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!this.options.ignoreInitial || forceAdd === true) {\n      this._emit(isDir ? 'addDir' : 'add', pp, stats);\n    }\n  }.bind(this);\n\n  var wh = this._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {\n      this._emitReady();\n      return this._emitReady();\n    }\n\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) emitAdd(processPath(path), stats);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > this.options.depth) return;\n\n      // scan the contents of the dir\n      readdirp({\n        root: wh.watchPath,\n        entryType: 'all',\n        fileFilter: wh.filterPath,\n        directoryFilter: wh.filterDir,\n        lstat: true,\n        depth: this.options.depth - (priorDepth || 0)\n      }).on('data', function(entry) {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;\n\n        var joinedPath = sysPath.join(wh.watchPath, entry.path);\n        var fullPath = entry.fullPath;\n\n        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          var curDepth = this.options.depth === undefined ?\n            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          emitAdd(joinedPath, entry.stat);\n        }\n      }.bind(this)).on('error', function() {\n        // Ignore readdirp errors\n      }).on('end', this._emitReady);\n    } else {\n      emitAdd(wh.watchPath, stats);\n      this._emitReady();\n    }\n  }.bind(this));\n\n  if (this.options.persistent && forceAdd !== true) {\n    var initWatch = function(error, realPath) {\n      if (this.closed) return;\n      var closer = this._watchWithFsEvents(\n        wh.watchPath,\n        sysPath.resolve(realPath || wh.watchPath),\n        processPath,\n        wh.globFilter\n      );\n      if (closer) {\n        this._closers[path] = this._closers[path] || [];\n        this._closers[path].push(closer);\n      }\n    }.bind(this);\n\n    if (typeof transform === 'function') {\n      // realpath has already been resolved\n      initWatch();\n    } else {\n      fs.realpath(wh.watchPath, initWatch);\n    }\n  }\n};\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}