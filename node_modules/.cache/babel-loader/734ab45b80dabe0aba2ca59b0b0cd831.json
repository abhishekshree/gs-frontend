{"ast":null,"code":"'use strict';\n\nvar path = require('path');\nvar inspect = require('util').inspect;\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + inspect(path));\n  }\n}\nfunction posix(path) {\n  assertPath(path);\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47 /*/*/;\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) return '//';\n  return path.slice(0, end);\n}\nfunction win32(path) {\n  assertPath(path);\n  var len = path.length;\n  if (len === 0) return '.';\n  var rootEnd = -1;\n  var end = -1;\n  var matchedSlash = true;\n  var offset = 0;\n  var code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (code === 47 /*/*/ || code === 92 /*\\*/) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n      code = path.charCodeAt(1);\n      if (code === 47 /*/*/ || code === 92 /*\\*/) {\n        // Matched double path separator at beginning\n        var j = 2;\n        var last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          code = path.charCodeAt(j);\n          if (code === 47 /*/*/ || code === 92 /*\\*/) break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code !== 47 /*/*/ && code !== 92 /*\\*/) break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code === 47 /*/*/ || code === 92 /*\\*/) break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (code >= 65 /*A*/ && code <= 90 /*Z*/ || code >= 97 /*a*/ && code <= 122 /*z*/) {\n      // Possible device root\n\n      code = path.charCodeAt(1);\n      if (path.charCodeAt(1) === 58 /*:*/) {\n        rootEnd = offset = 2;\n        if (len > 2) {\n          code = path.charCodeAt(2);\n          if (code === 47 /*/*/ || code === 92 /*\\*/) rootEnd = offset = 3;\n        }\n      }\n    }\n  } else if (code === 47 /*/*/ || code === 92 /*\\*/) {\n    return path[0];\n  }\n  for (var i = len - 1; i >= offset; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47 /*/*/ || code === 92 /*\\*/) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n  if (end === -1) {\n    if (rootEnd === -1) return '.';else end = rootEnd;\n  }\n  return path.slice(0, end);\n}\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;","map":{"version":3,"names":["path","require","inspect","assertPath","TypeError","posix","length","code","charCodeAt","hasRoot","end","matchedSlash","i","slice","win32","len","rootEnd","offset","j","last","module","exports","process","platform"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/path-dirname/index.js"],"sourcesContent":["'use strict';\n\nvar path = require('path');\nvar inspect = require('util').inspect;\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + inspect(path));\n  }\n}\n\nfunction posix(path) {\n  assertPath(path);\n  if (path.length === 0)\n    return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = (code === 47/*/*/);\n  var end = -1;\n  var matchedSlash = true;\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47/*/*/) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1)\n    return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1)\n    return '//';\n  return path.slice(0, end);\n}\n\nfunction win32(path) {\n  assertPath(path);\n  var len = path.length;\n  if (len === 0)\n    return '.';\n  var rootEnd = -1;\n  var end = -1;\n  var matchedSlash = true;\n  var offset = 0;\n  var code = path.charCodeAt(0);\n\n  // Try to match a root\n  if (len > 1) {\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      code = path.charCodeAt(1);\n      if (code === 47/*/*/ || code === 92/*\\*/) {\n        // Matched double path separator at beginning\n        var j = 2;\n        var last = j;\n        // Match 1 or more non-path separators\n        for (; j < len; ++j) {\n          code = path.charCodeAt(j);\n          if (code === 47/*/*/ || code === 92/*\\*/)\n            break;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          for (; j < len; ++j) {\n            code = path.charCodeAt(j);\n            if (code !== 47/*/*/ && code !== 92/*\\*/)\n              break;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            for (; j < len; ++j) {\n              code = path.charCodeAt(j);\n              if (code === 47/*/*/ || code === 92/*\\*/)\n                break;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a \"normal root\" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||\n               (code >= 97/*a*/ && code <= 122/*z*/)) {\n      // Possible device root\n\n      code = path.charCodeAt(1);\n      if (path.charCodeAt(1) === 58/*:*/) {\n        rootEnd = offset = 2;\n        if (len > 2) {\n          code = path.charCodeAt(2);\n          if (code === 47/*/*/ || code === 92/*\\*/)\n            rootEnd = offset = 3;\n        }\n      }\n    }\n  } else if (code === 47/*/*/ || code === 92/*\\*/) {\n    return path[0];\n  }\n\n  for (var i = len - 1; i >= offset; --i) {\n    code = path.charCodeAt(i);\n    if (code === 47/*/*/ || code === 92/*\\*/) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) {\n    if (rootEnd === -1)\n      return '.';\n    else\n      end = rootEnd;\n  }\n  return path.slice(0, end);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}