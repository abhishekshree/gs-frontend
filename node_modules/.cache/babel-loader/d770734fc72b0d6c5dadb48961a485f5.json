{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies\n */\nvar util = require('util');\nvar toRegex = require('to-regex');\nvar extend = require('extend-shallow');\n\n/**\n * Local dependencies\n */\n\nvar compilers = require('./lib/compilers');\nvar parsers = require('./lib/parsers');\nvar cache = require('./lib/cache');\nvar utils = require('./lib/utils');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm(list, patterns[, options]);\n *\n * console.log(nm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction nanomatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n  if (len === 1) {\n    return nanomatch.match(list, patterns[0], options);\n  }\n  var negated = false;\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n  while (++idx < len) {\n    var pattern = patterns[idx];\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));\n      negated = true;\n    } else {\n      keep.push.apply(keep, nanomatch.match(list, pattern, options));\n    }\n  }\n\n  // minimatch.match parity\n  if (negated && keep.length === 0) {\n    if (options && options.unixify === false) {\n      keep = list.slice();\n    } else {\n      var unixify = utils.unixify(options);\n      for (var i = 0; i < list.length; i++) {\n        keep.push(unixify(list[i]));\n      }\n    }\n  }\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.match(list, pattern[, options]);\n *\n * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nnanomatch.match = function (list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, nanomatch.matcher);\n  var matches = [];\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n  while (++idx < len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = nanomatch.not(matches, options.ignore, options);\n  }\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.isMatch(string, pattern[, options]);\n *\n * console.log(nm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(nm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nnanomatch.isMatch = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {\n    return false;\n  }\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n  var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the elements in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.some(list, patterns[, options]);\n *\n * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.some = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every element in the given `list` matches\n * at least one of the given glob `patterns`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.every(list, patterns[, options]);\n *\n * console.log(nm.every('foo.js', ['foo.js']));\n * // true\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.every = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.any(string, patterns[, options]);\n *\n * console.log(nm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(nm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.any = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n    return false;\n  }\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    if (nanomatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns`\n * match the specified string.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.all(string, patterns[, options]);\n *\n * console.log(nm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(nm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(nm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.all = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    if (!nanomatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.not(list, patterns[, options]);\n *\n * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nnanomatch.not = function (list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n  list = utils.arrayify(list);\n  var matches = utils.diff(list, nanomatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, nanomatch(list, ignore));\n  }\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.contains(string, pattern[, options]);\n *\n * console.log(nm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(nm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nnanomatch.contains = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (typeof patterns === 'string') {\n    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n      return false;\n    }\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n  var opts = extend({}, options, {\n    contains: true\n  });\n  return nanomatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nnanomatch.matchBase = function (pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(nm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nnanomatch.matchKeys = function (obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n  var keys = nanomatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.matcher(pattern[, options]);\n *\n * var isMatch = nm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nnanomatch.matcher = function matcher(pattern, options) {\n  if (utils.isEmptyString(pattern)) {\n    return function () {\n      return false;\n    };\n  }\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = nanomatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (nanomatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n    return function (str) {\n      if (equals(str)) {\n        return true;\n      }\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  // create matcher function\n  var matcherFn = test(re);\n  // set result object from compiler on matcher function,\n  // as a non-enumerable property. useful for debugging\n  utils.define(matcherFn, 'result', re.result);\n  return matcherFn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or\n * `null` if the pattern did not match.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.capture(pattern, string[, options]);\n *\n * console.log(nm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(nm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nnanomatch.capture = function (pattern, str, options) {\n  var re = nanomatch.makeRe(pattern, extend({\n    capture: true\n  }, options));\n  var unixify = utils.unixify(options);\n  function match() {\n    return function (string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n      return match.slice(1);\n    };\n  }\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.makeRe(pattern[, options]);\n *\n * console.log(nm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nnanomatch.makeRe = function (pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n  function makeRe() {\n    var opts = utils.extend({\n      wrap: false\n    }, options);\n    var result = nanomatch.create(pattern, opts);\n    var regex = toRegex(result.output, opts);\n    utils.define(regex, 'result', result);\n    return regex;\n  }\n  return memoize('makeRe', pattern, options, makeRe);\n};\n\n/**\n * Parses the given glob `pattern` and returns an object with the compiled `output`\n * and optional source `map`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.create(pattern[, options]);\n *\n * console.log(nm.create('abc/*.js'));\n * // { options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nnanomatch.create = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  function create() {\n    return nanomatch.compile(nanomatch.parse(pattern, options), options);\n  }\n  return memoize('create', pattern, options, create);\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.parse(pattern[, options]);\n *\n * var ast = nm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nnanomatch.parse = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n  return memoize('parse', pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.compile(ast[, options]);\n *\n * var ast = nm.parse('a/{b,c}/d');\n * console.log(nm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nnanomatch.compile = function (ast, options) {\n  if (typeof ast === 'string') {\n    ast = nanomatch.parse(ast, options);\n  }\n  function compile() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  }\n  return memoize('compile', ast.input, options, compile);\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * nm.clearCache();\n * ```\n * @api public\n */\n\nnanomatch.clearCache = function () {\n  nanomatch.cache.__data__ = {};\n};\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n  return memoize('compose', String(patterns), options, function () {\n    return function (file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `nanomatch`\n */\n\nnanomatch.compilers = compilers;\nnanomatch.parsers = parsers;\nnanomatch.cache = cache;\n\n/**\n * Expose `nanomatch`\n * @type {Function}\n */\n\nmodule.exports = nanomatch;","map":{"version":3,"names":["util","require","toRegex","extend","compilers","parsers","cache","utils","MAX_LENGTH","nanomatch","list","patterns","options","arrayify","len","length","match","negated","omit","keep","idx","pattern","charCodeAt","push","apply","slice","unixify","i","matches","diff","nodupes","unique","Array","isArray","TypeError","isMatch","memoize","matcher","ele","value","failglob","Error","nonull","nullglob","unescape","ignore","not","str","inspect","isEmptyString","equals","equalsPattern","some","every","any","all","opts","contains","containsPattern","matchBase","indexOf","basename","matchKeys","obj","isObject","keys","Object","pick","compose","RegExp","test","isString","hasSpecialChars","nocase","toLowerCase","matchPath","re","makeRe","matchBasename","regex","matcherFn","define","result","capture","string","exec","wrap","create","output","compile","parse","snapdragon","instantiate","ast","input","clearCache","__data__","matchers","String","file","type","fn","key","createKey","has","get","val","set","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/nanomatch/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar toRegex = require('to-regex');\nvar extend = require('extend-shallow');\n\n/**\n * Local dependencies\n */\n\nvar compilers = require('./lib/compilers');\nvar parsers = require('./lib/parsers');\nvar cache = require('./lib/cache');\nvar utils = require('./lib/utils');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm(list, patterns[, options]);\n *\n * console.log(nm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction nanomatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return nanomatch.match(list, patterns[0], options);\n  }\n\n  var negated = false;\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, nanomatch.match(list, pattern.slice(1), options));\n      negated = true;\n    } else {\n      keep.push.apply(keep, nanomatch.match(list, pattern, options));\n    }\n  }\n\n  // minimatch.match parity\n  if (negated && keep.length === 0) {\n    if (options && options.unixify === false) {\n      keep = list.slice();\n    } else {\n      var unixify = utils.unixify(options);\n      for (var i = 0; i < list.length; i++) {\n        keep.push(unixify(list[i]));\n      }\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.match(list, pattern[, options]);\n *\n * console.log(nm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nnanomatch.match = function(list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, nanomatch.matcher);\n  var matches = [];\n\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = nanomatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.isMatch(string, pattern[, options]);\n *\n * console.log(nm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(nm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nnanomatch.isMatch = function(str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (utils.isEmptyString(str) || utils.isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize('isMatch', pattern, options, nanomatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the elements in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.some(list, patterns[, options]);\n *\n * console.log(nm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(nm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.some = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Returns true if every element in the given `list` matches\n * at least one of the given glob `patterns`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.every(list, patterns[, options]);\n *\n * console.log(nm.every('foo.js', ['foo.js']));\n * // true\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(nm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(nm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.every = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    if (nanomatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.any(string, patterns[, options]);\n *\n * console.log(nm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(nm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.any = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (nanomatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns`\n * match the specified string.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.all(string, patterns[, options]);\n *\n * console.log(nm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(nm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(nm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(nm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nnanomatch.all = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (!nanomatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.not(list, patterns[, options]);\n *\n * console.log(nm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nnanomatch.not = function(list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n\n  list = utils.arrayify(list);\n\n  var matches = utils.diff(list, nanomatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, nanomatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.contains(string, pattern[, options]);\n *\n * console.log(nm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(nm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nnanomatch.contains = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    if (utils.isEmptyString(str) || utils.isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {contains: true});\n  return nanomatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nnanomatch.matchBase = function(pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(nm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nnanomatch.matchKeys = function(obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n  var keys = nanomatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.matcher(pattern[, options]);\n *\n * var isMatch = nm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nnanomatch.matcher = function matcher(pattern, options) {\n  if (utils.isEmptyString(pattern)) {\n    return function() {\n      return false;\n    };\n  }\n\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = nanomatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (nanomatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n\n    return function(str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  // create matcher function\n  var matcherFn = test(re);\n  // set result object from compiler on matcher function,\n  // as a non-enumerable property. useful for debugging\n  utils.define(matcherFn, 'result', re.result);\n  return matcherFn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or\n * `null` if the pattern did not match.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.capture(pattern, string[, options]);\n *\n * console.log(nm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(nm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nnanomatch.capture = function(pattern, str, options) {\n  var re = nanomatch.makeRe(pattern, extend({capture: true}, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function(string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.makeRe(pattern[, options]);\n *\n * console.log(nm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nnanomatch.makeRe = function(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var opts = utils.extend({wrap: false}, options);\n    var result = nanomatch.create(pattern, opts);\n    var regex = toRegex(result.output, opts);\n    utils.define(regex, 'result', result);\n    return regex;\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n\n/**\n * Parses the given glob `pattern` and returns an object with the compiled `output`\n * and optional source `map`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.create(pattern[, options]);\n *\n * console.log(nm.create('abc/*.js'));\n * // { options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nnanomatch.create = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  function create() {\n    return nanomatch.compile(nanomatch.parse(pattern, options), options);\n  }\n  return memoize('create', pattern, options, create);\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.parse(pattern[, options]);\n *\n * var ast = nm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nnanomatch.parse = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize('parse', pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var nm = require('nanomatch');\n * nm.compile(ast[, options]);\n *\n * var ast = nm.parse('a/{b,c}/d');\n * console.log(nm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nnanomatch.compile = function(ast, options) {\n  if (typeof ast === 'string') {\n    ast = nanomatch.parse(ast, options);\n  }\n\n  function compile() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  }\n\n  return memoize('compile', ast.input, options, compile);\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * nm.clearCache();\n * ```\n * @api public\n */\n\nnanomatch.clearCache = function() {\n  nanomatch.cache.__data__ = {};\n};\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n\n  return memoize('compose', String(patterns), options, function() {\n    return function(file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `nanomatch`\n */\n\nnanomatch.compilers = compilers;\nnanomatch.parsers = parsers;\nnanomatch.cache = cache;\n\n/**\n * Expose `nanomatch`\n * @type {Function}\n */\n\nmodule.exports = nanomatch;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}