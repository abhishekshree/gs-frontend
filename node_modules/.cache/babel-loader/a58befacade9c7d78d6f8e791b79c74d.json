{"ast":null,"code":"'use strict';\n\nvar Combine = require('ordered-read-streams');\nvar unique = require('unique-stream');\nvar pumpify = require('pumpify');\nvar isNegatedGlob = require('is-negated-glob');\nvar extend = require('extend');\nvar GlobStream = require('./readable');\nfunction globStream(globs, opt) {\n  if (!opt) {\n    opt = {};\n  }\n  var ourOpt = extend({}, opt);\n  var ignore = ourOpt.ignore;\n  ourOpt.cwd = typeof ourOpt.cwd === 'string' ? ourOpt.cwd : process.cwd();\n  ourOpt.dot = typeof ourOpt.dot === 'boolean' ? ourOpt.dot : false;\n  ourOpt.silent = typeof ourOpt.silent === 'boolean' ? ourOpt.silent : true;\n  ourOpt.cwdbase = typeof ourOpt.cwdbase === 'boolean' ? ourOpt.cwdbase : false;\n  ourOpt.uniqueBy = typeof ourOpt.uniqueBy === 'string' || typeof ourOpt.uniqueBy === 'function' ? ourOpt.uniqueBy : 'path';\n  if (ourOpt.cwdbase) {\n    ourOpt.base = ourOpt.cwd;\n  }\n  // Normalize string `ignore` to array\n  if (typeof ignore === 'string') {\n    ignore = [ignore];\n  }\n  // Ensure `ignore` is an array\n  if (!Array.isArray(ignore)) {\n    ignore = [];\n  }\n\n  // Only one glob no need to aggregate\n  if (!Array.isArray(globs)) {\n    globs = [globs];\n  }\n  var positives = [];\n  var negatives = [];\n  globs.forEach(sortGlobs);\n  function sortGlobs(globString, index) {\n    if (typeof globString !== 'string') {\n      throw new Error('Invalid glob at index ' + index);\n    }\n    var glob = isNegatedGlob(globString);\n    var globArray = glob.negated ? negatives : positives;\n    globArray.push({\n      index: index,\n      glob: glob.pattern\n    });\n  }\n  if (positives.length === 0) {\n    throw new Error('Missing positive glob');\n  }\n\n  // Create all individual streams\n  var streams = positives.map(streamFromPositive);\n\n  // Then just pipe them to a single unique stream and return it\n  var aggregate = new Combine(streams);\n  var uniqueStream = unique(ourOpt.uniqueBy);\n  return pumpify.obj(aggregate, uniqueStream);\n  function streamFromPositive(positive) {\n    var negativeGlobs = negatives.filter(indexGreaterThan(positive.index)).map(toGlob).concat(ignore);\n    return new GlobStream(positive.glob, negativeGlobs, ourOpt);\n  }\n}\nfunction indexGreaterThan(index) {\n  return function (obj) {\n    return obj.index > index;\n  };\n}\nfunction toGlob(obj) {\n  return obj.glob;\n}\nmodule.exports = globStream;","map":{"version":3,"names":["Combine","require","unique","pumpify","isNegatedGlob","extend","GlobStream","globStream","globs","opt","ourOpt","ignore","cwd","process","dot","silent","cwdbase","uniqueBy","base","Array","isArray","positives","negatives","forEach","sortGlobs","globString","index","Error","glob","globArray","negated","push","pattern","length","streams","map","streamFromPositive","aggregate","uniqueStream","obj","positive","negativeGlobs","filter","indexGreaterThan","toGlob","concat","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/glob-stream/index.js"],"sourcesContent":["'use strict';\n\nvar Combine = require('ordered-read-streams');\nvar unique = require('unique-stream');\nvar pumpify = require('pumpify');\nvar isNegatedGlob = require('is-negated-glob');\nvar extend = require('extend');\n\nvar GlobStream = require('./readable');\n\nfunction globStream(globs, opt) {\n  if (!opt) {\n    opt = {};\n  }\n\n  var ourOpt = extend({}, opt);\n  var ignore = ourOpt.ignore;\n\n  ourOpt.cwd = typeof ourOpt.cwd === 'string' ? ourOpt.cwd : process.cwd();\n  ourOpt.dot = typeof ourOpt.dot === 'boolean' ? ourOpt.dot : false;\n  ourOpt.silent = typeof ourOpt.silent === 'boolean' ? ourOpt.silent : true;\n  ourOpt.cwdbase = typeof ourOpt.cwdbase === 'boolean' ? ourOpt.cwdbase : false;\n  ourOpt.uniqueBy =  typeof ourOpt.uniqueBy === 'string' ||\n                    typeof ourOpt.uniqueBy === 'function' ? ourOpt.uniqueBy : 'path';\n\n  if (ourOpt.cwdbase) {\n    ourOpt.base = ourOpt.cwd;\n  }\n  // Normalize string `ignore` to array\n  if (typeof ignore === 'string') {\n    ignore = [ignore];\n  }\n  // Ensure `ignore` is an array\n  if (!Array.isArray(ignore)) {\n    ignore = [];\n  }\n\n  // Only one glob no need to aggregate\n  if (!Array.isArray(globs)) {\n    globs = [globs];\n  }\n\n  var positives = [];\n  var negatives = [];\n\n  globs.forEach(sortGlobs);\n\n  function sortGlobs(globString, index) {\n    if (typeof globString !== 'string') {\n      throw new Error('Invalid glob at index ' + index);\n    }\n\n    var glob = isNegatedGlob(globString);\n    var globArray = glob.negated ? negatives : positives;\n\n    globArray.push({\n      index: index,\n      glob: glob.pattern,\n    });\n  }\n\n  if (positives.length === 0) {\n    throw new Error('Missing positive glob');\n  }\n\n  // Create all individual streams\n  var streams = positives.map(streamFromPositive);\n\n  // Then just pipe them to a single unique stream and return it\n  var aggregate = new Combine(streams);\n  var uniqueStream = unique(ourOpt.uniqueBy);\n\n  return pumpify.obj(aggregate, uniqueStream);\n\n  function streamFromPositive(positive) {\n    var negativeGlobs = negatives\n      .filter(indexGreaterThan(positive.index))\n      .map(toGlob)\n      .concat(ignore);\n    return new GlobStream(positive.glob, negativeGlobs, ourOpt);\n  }\n}\n\nfunction indexGreaterThan(index) {\n  return function(obj) {\n    return obj.index > index;\n  };\n}\n\nfunction toGlob(obj) {\n  return obj.glob;\n}\n\nmodule.exports = globStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}