{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar isBinaryPath = require('is-binary-path');\n\n// fs.watch helpers\n\n// object to hold per-process fs.watch instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchInstances = Object.create(null);\n\n// Private function: Instantiates the fs.watch interface\n\n// * path       - string, path to be watched\n// * options    - object, options to be passed to fs.watch\n// * listener   - function, main event handler\n// * errHandler - function, handler which emits info about errors\n// * emitRaw    - function, handler which emits raw event data\n\n// Returns new fsevents instance\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function (rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    });\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath));\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n// Private function: Helper for passing fs.watch event data to a\n// collection of listeners\n\n// * fullPath   - string, absolute path bound to the fs.watch instance\n// * type       - string, listener type\n// * val[1..3]  - arguments to be passed to listeners\n\n// Returns nothing\nfunction fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  if (!FsWatchInstances[fullPath]) return;\n  FsWatchInstances[fullPath][type].forEach(function (listener) {\n    listener(val1, val2, val3);\n  });\n}\n\n// Private function: Instantiates the fs.watch interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watch\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var errHandler = handlers.errHandler;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchInstances[fullPath];\n  var watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n  if (!container) {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, 'listeners'), errHandler,\n    // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, 'rawEmitters'));\n    if (!watcher) return;\n    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');\n    watcher.on('error', function (error) {\n      container.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (process.platform === 'win32' && error.code === 'EPERM') {\n        fs.open(path, 'r', function (err, fd) {\n          if (!err) fs.close(fd, function (err) {\n            if (!err) broadcastErr(error);\n          });\n        });\n      } else {\n        broadcastErr(error);\n      }\n    });\n    container = FsWatchInstances[fullPath] = {\n      listeners: [listener],\n      errHandlers: [errHandler],\n      rawEmitters: [rawEmitter],\n      watcher: watcher\n    };\n  } else {\n    container.listeners.push(listener);\n    container.errHandlers.push(errHandler);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watch\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.errHandlers[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      if (!container.watcherUnusable) {\n        // check to protect against issue #730\n        container.watcher.close();\n      }\n      delete FsWatchInstances[fullPath];\n    }\n  };\n}\n\n// fs.watchFile helpers\n\n// object to hold per-process fs.watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchFileInstances = Object.create(null);\n\n// Private function: Instantiates the fs.watchFile interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watchFile\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchFileInstances[fullPath];\n  var listeners = [];\n  var rawEmitters = [];\n  if (container && (container.options.persistent < options.persistent || container.options.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = container.listeners;\n    rawEmitters = container.rawEmitters;\n    fs.unwatchFile(fullPath);\n    container = false;\n  }\n  if (!container) {\n    listeners.push(listener);\n    rawEmitters.push(rawEmitter);\n    container = FsWatchFileInstances[fullPath] = {\n      listeners: listeners,\n      rawEmitters: rawEmitters,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function (curr, prev) {\n        container.rawEmitters.forEach(function (rawEmitter) {\n          rawEmitter('change', fullPath, {\n            curr: curr,\n            prev: prev\n          });\n        });\n        var currmtime = curr.mtime.getTime();\n        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {\n          container.listeners.forEach(function (listener) {\n            listener(path, curr);\n          });\n        }\n      })\n    };\n  } else {\n    container.listeners.push(listener);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watchFile\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      fs.unwatchFile(fullPath);\n      delete FsWatchFileInstances[fullPath];\n    }\n  };\n}\n\n// fake constructor for attaching nodefs-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction NodeFsHandler() {}\n\n// Private method: Watch file for changes with fs.watchFile or fs.watch.\n\n// * path     - string, path to file or directory.\n// * listener - function, to be executed on fs change.\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._watchWithNodeFs = function (path, listener) {\n  var directory = sysPath.dirname(path);\n  var basename = sysPath.basename(path);\n  var parent = this._getWatchedDir(directory);\n  parent.add(basename);\n  var absolutePath = sysPath.resolve(path);\n  var options = {\n    persistent: this.options.persistent\n  };\n  if (!listener) listener = Function.prototype; // empty function\n\n  var closer;\n  if (this.options.usePolling) {\n    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ? this.options.binaryInterval : this.options.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener: listener,\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener: listener,\n      errHandler: this._handleError.bind(this),\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  }\n  return closer;\n};\n\n// Private method: Watch a file and emit add event if warranted\n\n// * file       - string, the file's path\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * callback   - function, called when done processing as a newly seen file\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleFile = function (file, stats, initialAdd, callback) {\n  var dirname = sysPath.dirname(file);\n  var basename = sysPath.basename(file);\n  var parent = this._getWatchedDir(dirname);\n  // stats is always present\n  var prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return callback();\n\n  // kick off the watcher\n  var closer = this._watchWithNodeFs(file, function (path, newStats) {\n    if (!this._throttle('watch', file, 5)) return;\n    if (!newStats || newStats && newStats.mtime.getTime() === 0) {\n      fs.stat(file, function (error, newStats) {\n        // Fix issues where mtime is null but file is still present\n        if (error) {\n          this._remove(dirname, basename);\n        } else {\n          // Check that change event was not fired because of changed only accessTime.\n          var at = newStats.atime.getTime();\n          var mt = newStats.mtime.getTime();\n          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {\n            this._emit('change', file, newStats);\n          }\n          prevStats = newStats;\n        }\n      }.bind(this));\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      var at = newStats.atime.getTime();\n      var mt = newStats.mtime.getTime();\n      if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {\n        this._emit('change', file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }.bind(this));\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.options.ignoreInitial)) {\n    if (!this._throttle('add', file, 0)) return;\n    this._emit('add', file, stats);\n  }\n  if (callback) callback();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered while reading a dir\n\n// * entry      - object, entry object returned by readdirp\n// * directory  - string, path of the directory being read\n// * path       - string, path of this item\n// * item       - string, basename of this item\n\n// Returns true if no more processing is needed for this entry.\nNodeFsHandler.prototype._handleSymlink = function (entry, directory, path, item) {\n  var full = entry.fullPath;\n  var dir = this._getWatchedDir(directory);\n  if (!this.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this._readyCount++;\n    fs.realpath(path, function (error, linkPath) {\n      if (dir.has(item)) {\n        if (this._symlinkPaths[full] !== linkPath) {\n          this._symlinkPaths[full] = linkPath;\n          this._emit('change', path, entry.stat);\n        }\n      } else {\n        dir.add(item);\n        this._symlinkPaths[full] = linkPath;\n        this._emit('add', path, entry.stat);\n      }\n      this._emitReady();\n    }.bind(this));\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[full]) return true;else this._symlinkPaths[full] = true;\n};\n\n// Private method: Read directory to add / remove files from `@watched` list\n// and re-read it on change.\n\n// * dir        - string, fs path.\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * wh         - object, common watch helpers for this path\n// * callback   - function, called when dir scan is complete\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleDir = function (dir, stats, initialAdd, depth, target, wh, callback) {\n  var parentDir = this._getWatchedDir(sysPath.dirname(dir));\n  var tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this._getWatchedDir(dir);\n  var read = function (directory, initialAdd, done) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, '');\n    if (!wh.hasGlob) {\n      var throttler = this._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n    var previous = this._getWatchedDir(wh.path);\n    var current = [];\n    readdirp({\n      root: directory,\n      entryType: 'all',\n      fileFilter: wh.filterPath,\n      directoryFilter: wh.filterDir,\n      depth: 0,\n      lstat: true\n    }).on('data', function (entry) {\n      var item = entry.path;\n      var path = sysPath.join(directory, item);\n      current.push(item);\n      if (entry.stat.isSymbolicLink() && this._handleSymlink(entry, directory, path, item)) return;\n\n      // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n      if (item === target || !target && !previous.has(item)) {\n        this._readyCount++;\n\n        // ensure relativeness of path is preserved in case of watcher reuse\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }.bind(this)).on('end', function () {\n      var wasThrottled = throttler ? throttler.clear() : false;\n      if (done) done();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.children().filter(function (item) {\n        return item !== directory && current.indexOf(item) === -1 && (\n        // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath.resolve(directory, item)\n        }));\n      }).forEach(function (item) {\n        this._remove(directory, item);\n      }, this);\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) read(directory, false);\n    }.bind(this)).on('error', this._handleError.bind(this));\n  }.bind(this);\n  var closer;\n  if (this.options.depth == null || depth <= this.options.depth) {\n    if (!target) read(dir, initialAdd, callback);\n    closer = this._watchWithNodeFs(dir, function (dirPath, stats) {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtime.getTime() === 0) return;\n      read(dirPath, false);\n    });\n  } else {\n    callback();\n  }\n  return closer;\n};\n\n// Private method: Handle added file, directory, or glob pattern.\n// Delegates call to _handleFile / _handleDir after checks.\n\n// * path       - string, path to file or directory.\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * callback   - function, indicates whether the path was found or not\n\n// Returns nothing\nNodeFsHandler.prototype._addToNodeFs = function (path, initialAdd, priorWh, depth, target, callback) {\n  if (!callback) callback = Function.prototype;\n  var ready = this._emitReady;\n  if (this._isIgnored(path) || this.closed) {\n    ready();\n    return callback(null, false);\n  }\n  var wh = this._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = priorWh.filterPath;\n    wh.filterDir = priorWh.filterDir;\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function (error, stats) {\n    if (this._handleError(error)) return callback(null, path);\n    if (this._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return callback(null, false);\n    }\n    var initDir = function (dir, target) {\n      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);\n    }.bind(this);\n    var closer;\n    if (stats.isDirectory()) {\n      closer = initDir(wh.watchPath, target);\n    } else if (stats.isSymbolicLink()) {\n      var parent = sysPath.dirname(wh.watchPath);\n      this._getWatchedDir(parent).add(wh.watchPath);\n      this._emit('add', wh.watchPath, stats);\n      closer = initDir(parent, path);\n\n      // preserve this symlink's target path\n      fs.realpath(path, function (error, targetPath) {\n        this._symlinkPaths[sysPath.resolve(path)] = targetPath;\n        ready();\n      }.bind(this));\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);\n    }\n    if (closer) {\n      this._closers[path] = this._closers[path] || [];\n      this._closers[path].push(closer);\n    }\n    callback(null, false);\n  }.bind(this));\n};\nmodule.exports = NodeFsHandler;","map":{"version":3,"names":["fs","require","sysPath","readdirp","isBinaryPath","FsWatchInstances","Object","create","createFsWatchInstance","path","options","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","resolve","join","watch","error","fullPath","type","val1","val2","val3","forEach","setFsWatchListener","handlers","rawEmitter","container","watcher","persistent","close","bind","broadcastErr","on","watcherUnusable","process","platform","code","open","err","fd","listeners","errHandlers","rawEmitters","push","listenerIndex","length","keys","FsWatchFileInstances","setFsWatchFileListener","interval","unwatchFile","watchFile","curr","prev","currmtime","mtime","getTime","size","NodeFsHandler","prototype","_watchWithNodeFs","directory","dirname","basename","parent","_getWatchedDir","add","absolutePath","Function","closer","usePolling","enableBinaryInterval","binaryInterval","emit","_handleError","_handleFile","file","stats","initialAdd","callback","prevStats","has","newStats","_throttle","stat","_remove","at","atime","mt","_emit","ignoreInitial","_handleSymlink","entry","item","full","dir","followSymlinks","_readyCount","realpath","linkPath","_symlinkPaths","_emitReady","_handleDir","depth","target","wh","parentDir","tracked","hasGlob","globFilter","read","done","throttler","previous","current","root","entryType","fileFilter","filterPath","directoryFilter","filterDir","lstat","isSymbolicLink","relative","_addToNodeFs","wasThrottled","clear","children","filter","indexOf","dirPath","priorWh","ready","_isIgnored","closed","_getWatchHelpers","statMethod","watchPath","initDir","isDirectory","targetPath","_closers","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/chokidar/lib/nodefs-handler.js"],"sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar isBinaryPath = require('is-binary-path');\n\n// fs.watch helpers\n\n// object to hold per-process fs.watch instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchInstances = Object.create(null);\n\n\n// Private function: Instantiates the fs.watch interface\n\n// * path       - string, path to be watched\n// * options    - object, options to be passed to fs.watch\n// * listener   - function, main event handler\n// * errHandler - function, handler which emits info about errors\n// * emitRaw    - function, handler which emits raw event data\n\n// Returns new fsevents instance\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function(rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n// Private function: Helper for passing fs.watch event data to a\n// collection of listeners\n\n// * fullPath   - string, absolute path bound to the fs.watch instance\n// * type       - string, listener type\n// * val[1..3]  - arguments to be passed to listeners\n\n// Returns nothing\nfunction fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  if (!FsWatchInstances[fullPath]) return;\n  FsWatchInstances[fullPath][type].forEach(function(listener) {\n    listener(val1, val2, val3);\n  });\n}\n\n// Private function: Instantiates the fs.watch interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watch\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var errHandler = handlers.errHandler;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchInstances[fullPath];\n  var watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (!container) {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, 'listeners'),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')\n    );\n    if (!watcher) return;\n    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');\n    watcher.on('error', function(error) {\n      container.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (process.platform === 'win32' && error.code === 'EPERM') {\n        fs.open(path, 'r', function(err, fd) {\n          if (!err) fs.close(fd, function(err) {\n            if (!err) broadcastErr(error);\n          });\n        });\n      } else {\n        broadcastErr(error);\n      }\n    });\n    container = FsWatchInstances[fullPath] = {\n      listeners: [listener],\n      errHandlers: [errHandler],\n      rawEmitters: [rawEmitter],\n      watcher: watcher\n    };\n  } else {\n    container.listeners.push(listener);\n    container.errHandlers.push(errHandler);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watch\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.errHandlers[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      if (!container.watcherUnusable) { // check to protect against issue #730\n        container.watcher.close();\n      }\n      delete FsWatchInstances[fullPath];\n    }\n  };\n}\n\n// fs.watchFile helpers\n\n// object to hold per-process fs.watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchFileInstances = Object.create(null);\n\n// Private function: Instantiates the fs.watchFile interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watchFile\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchFileInstances[fullPath];\n  var listeners = [];\n  var rawEmitters = [];\n  if (\n    container && (\n      container.options.persistent < options.persistent ||\n      container.options.interval > options.interval\n    )\n  ) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = container.listeners;\n    rawEmitters = container.rawEmitters;\n    fs.unwatchFile(fullPath);\n    container = false;\n  }\n  if (!container) {\n    listeners.push(listener);\n    rawEmitters.push(rawEmitter);\n    container = FsWatchFileInstances[fullPath] = {\n      listeners: listeners,\n      rawEmitters: rawEmitters,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function(curr, prev) {\n        container.rawEmitters.forEach(function(rawEmitter) {\n          rawEmitter('change', fullPath, {curr: curr, prev: prev});\n        });\n        var currmtime = curr.mtime.getTime();\n        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {\n          container.listeners.forEach(function(listener) {\n            listener(path, curr);\n          });\n        }\n      })\n    };\n  } else {\n    container.listeners.push(listener);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watchFile\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      fs.unwatchFile(fullPath);\n      delete FsWatchFileInstances[fullPath];\n    }\n  };\n}\n\n// fake constructor for attaching nodefs-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction NodeFsHandler() {}\n\n// Private method: Watch file for changes with fs.watchFile or fs.watch.\n\n// * path     - string, path to file or directory.\n// * listener - function, to be executed on fs change.\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._watchWithNodeFs =\nfunction(path, listener) {\n  var directory = sysPath.dirname(path);\n  var basename = sysPath.basename(path);\n  var parent = this._getWatchedDir(directory);\n  parent.add(basename);\n  var absolutePath = sysPath.resolve(path);\n  var options = {persistent: this.options.persistent};\n  if (!listener) listener = Function.prototype; // empty function\n\n  var closer;\n  if (this.options.usePolling) {\n    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?\n      this.options.binaryInterval : this.options.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener: listener,\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener: listener,\n      errHandler: this._handleError.bind(this),\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  }\n  return closer;\n};\n\n// Private method: Watch a file and emit add event if warranted\n\n// * file       - string, the file's path\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * callback   - function, called when done processing as a newly seen file\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleFile =\nfunction(file, stats, initialAdd, callback) {\n  var dirname = sysPath.dirname(file);\n  var basename = sysPath.basename(file);\n  var parent = this._getWatchedDir(dirname);\n  // stats is always present\n  var prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return callback();\n\n  // kick off the watcher\n  var closer = this._watchWithNodeFs(file, function(path, newStats) {\n    if (!this._throttle('watch', file, 5)) return;\n    if (!newStats || newStats && newStats.mtime.getTime() === 0) {\n      fs.stat(file, function(error, newStats) {\n        // Fix issues where mtime is null but file is still present\n        if (error) {\n          this._remove(dirname, basename);\n        } else {\n          // Check that change event was not fired because of changed only accessTime.\n          var at = newStats.atime.getTime();\n          var mt = newStats.mtime.getTime();\n          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {\n            this._emit('change', file, newStats);\n          }\n          prevStats = newStats;\n        }\n      }.bind(this));\n    // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      var at = newStats.atime.getTime();\n      var mt = newStats.mtime.getTime();\n      if (!at || at <= mt ||  mt !== prevStats.mtime.getTime()) {\n        this._emit('change', file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }.bind(this));\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.options.ignoreInitial)) {\n    if (!this._throttle('add', file, 0)) return;\n    this._emit('add', file, stats);\n  }\n\n  if (callback) callback();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered while reading a dir\n\n// * entry      - object, entry object returned by readdirp\n// * directory  - string, path of the directory being read\n// * path       - string, path of this item\n// * item       - string, basename of this item\n\n// Returns true if no more processing is needed for this entry.\nNodeFsHandler.prototype._handleSymlink =\nfunction(entry, directory, path, item) {\n  var full = entry.fullPath;\n  var dir = this._getWatchedDir(directory);\n\n  if (!this.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this._readyCount++;\n    fs.realpath(path, function(error, linkPath) {\n      if (dir.has(item)) {\n        if (this._symlinkPaths[full] !== linkPath) {\n          this._symlinkPaths[full] = linkPath;\n          this._emit('change', path, entry.stat);\n        }\n      } else {\n        dir.add(item);\n        this._symlinkPaths[full] = linkPath;\n        this._emit('add', path, entry.stat);\n      }\n      this._emitReady();\n    }.bind(this));\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[full]) return true;\n  else this._symlinkPaths[full] = true;\n};\n\n// Private method: Read directory to add / remove files from `@watched` list\n// and re-read it on change.\n\n// * dir        - string, fs path.\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * wh         - object, common watch helpers for this path\n// * callback   - function, called when dir scan is complete\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleDir =\nfunction(dir, stats, initialAdd, depth, target, wh, callback) {\n  var parentDir = this._getWatchedDir(sysPath.dirname(dir));\n  var tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this._getWatchedDir(dir);\n\n  var read = function(directory, initialAdd, done) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, '');\n\n    if (!wh.hasGlob) {\n      var throttler = this._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    var previous = this._getWatchedDir(wh.path);\n    var current = [];\n\n    readdirp({\n      root: directory,\n      entryType: 'all',\n      fileFilter: wh.filterPath,\n      directoryFilter: wh.filterDir,\n      depth: 0,\n      lstat: true\n    }).on('data', function(entry) {\n      var item = entry.path;\n      var path = sysPath.join(directory, item);\n      current.push(item);\n\n      if (entry.stat.isSymbolicLink() &&\n        this._handleSymlink(entry, directory, path, item)) return;\n\n      // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n      if (item === target || !target && !previous.has(item)) {\n        this._readyCount++;\n\n        // ensure relativeness of path is preserved in case of watcher reuse\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }.bind(this)).on('end', function() {\n      var wasThrottled = throttler ? throttler.clear() : false;\n      if (done) done();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.children().filter(function(item) {\n        return item !== directory &&\n          current.indexOf(item) === -1 &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach(function(item) {\n        this._remove(directory, item);\n      }, this);\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) read(directory, false);\n    }.bind(this)).on('error', this._handleError.bind(this));\n  }.bind(this);\n\n  var closer;\n\n  if (this.options.depth == null || depth <= this.options.depth) {\n    if (!target) read(dir, initialAdd, callback);\n    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtime.getTime() === 0) return;\n\n      read(dirPath, false);\n    });\n  } else {\n    callback();\n  }\n  return closer;\n};\n\n// Private method: Handle added file, directory, or glob pattern.\n// Delegates call to _handleFile / _handleDir after checks.\n\n// * path       - string, path to file or directory.\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * callback   - function, indicates whether the path was found or not\n\n// Returns nothing\nNodeFsHandler.prototype._addToNodeFs =\nfunction(path, initialAdd, priorWh, depth, target, callback) {\n  if (!callback) callback = Function.prototype;\n  var ready = this._emitReady;\n  if (this._isIgnored(path) || this.closed) {\n    ready();\n    return callback(null, false);\n  }\n\n  var wh = this._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = priorWh.filterPath;\n    wh.filterDir = priorWh.filterDir;\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error)) return callback(null, path);\n    if (this._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return callback(null, false);\n    }\n\n    var initDir = function(dir, target) {\n      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);\n    }.bind(this);\n\n    var closer;\n    if (stats.isDirectory()) {\n      closer = initDir(wh.watchPath, target);\n    } else if (stats.isSymbolicLink()) {\n      var parent = sysPath.dirname(wh.watchPath);\n      this._getWatchedDir(parent).add(wh.watchPath);\n      this._emit('add', wh.watchPath, stats);\n      closer = initDir(parent, path);\n\n      // preserve this symlink's target path\n      fs.realpath(path, function(error, targetPath) {\n        this._symlinkPaths[sysPath.resolve(path)] = targetPath;\n        ready();\n      }.bind(this));\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);\n    }\n\n    if (closer) {\n      this._closers[path] = this._closers[path] || [];\n      this._closers[path].push(closer);\n    }\n    callback(null, false);\n  }.bind(this));\n};\n\nmodule.exports = NodeFsHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}