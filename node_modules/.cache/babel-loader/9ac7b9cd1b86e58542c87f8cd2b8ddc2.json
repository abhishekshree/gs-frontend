{"ast":null,"code":"import _slicedToArray from \"/home/krishnansh/Documents/WebDev/PS/tom-tom-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/home/krishnansh/Documents/WebDev/PS/tom-tom-app/src/Map.js\";\nimport React from 'react';\nimport \"@tomtom-international/web-sdk-maps/dist/maps.css\";\nimport * as ttservices from \"@tomtom-international/web-sdk-services\";\nimport tt from \"@tomtom-international/web-sdk-maps\";\nimport { useEffect, useState, useRef } from \"react\";\n// import { fromSeconds } from \"from-seconds\";\nimport { api_key } from \"./constants.js\";\nimport axios from \"axios\";\nvar getSnapFunction = function getSnapFunction() {\n  axios.get(\"https://api.tomtom.com/snap-to-roads/1/snap-to-roads?points=4.6104,52.3757;4.6140,52.393&fields={projectedPoints{type,geometry{type,coordinates},properties{routeIndex}},route{type,geometry{type,coordinates},properties{id,speedRestrictions{maximumSpeed{value,unit}}}}}&key=8h504Wc4AXL6OPndqhrtKf70AovVBL3V\").then(function (res) {\n    console.log(res.data);\n    res.data.route.forEach(function (item) {\n      map.addLayer({\n        id: Math.random().toString(),\n        type: \"line\",\n        source: {\n          type: \"geojson\",\n          data: {\n            type: \"FeatureCollection\",\n            features: [{\n              type: \"Feature\",\n              geometry: {\n                type: \"LineString\",\n                properties: {},\n                coordinates: item.geometry.coordinates\n              }\n            }]\n          }\n        },\n        layout: {\n          \"line-cap\": \"round\",\n          \"line-join\": \"round\"\n        },\n        paint: {\n          \"line-color\": \"#ff0000\",\n          \"line-width\": 2\n        }\n      });\n    });\n    map.setCenter([parseFloat(4.6104), parseFloat(52.3757)]);\n  }).catch(function (err) {\n    return console.log(err);\n  });\n};\nfunction Map(_ref) {\n  var currLocation = _ref.currLocation,\n    deliveryLocation = _ref.deliveryLocation,\n    destinations = _ref.destinations,\n    zoom_level = _ref.zoom_level,\n    travel_mode = _ref.travel_mode;\n  var mapElement = useRef();\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    map = _useState2[0],\n    setMap = _useState2[1];\n  var _useState3 = useState(destinations),\n    _useState4 = _slicedToArray(_useState3, 2),\n    waypoints = _useState4[0],\n    setWayPoints = _useState4[1];\n  function create_delivery_marker(location) {\n    var marker_el = document.createElement(\"div\");\n    marker_el.className = 'marker-delivery';\n    // const popup = new tt.Popup({ offset: 20 }).setText(location.name);\n    var marker = new tt.Marker({\n      element: marker_el,\n      anchor: \"bottom\"\n    }).setLngLat([location.lng, location.lat]).addTo(map);\n    return marker;\n  }\n  var URL = \"https://api.tomtom.com/routing/waypointoptimization/1?key=\".concat(api_key);\n  // const optimize_routes = () => {\n  //     const data = {\n  //         waypoints: waypoints.map((location) => {\n  //             return {\n  //             point: {\n  //                 latitude: location.lat,\n  //                 longitude: location.lng,\n  //             },\n  //             };\n  //         }),\n  //         options: {\n  //             travelMode: travel_mode,\n  //             vehicleMaxSpeed: 0,\n  //             vehicleCommercial: true,\n  //             vehicleLoadType: [\"otherHazmatGeneral\"],\n  //             traffic: \"live\",\n  //             departAt: \"now\",\n  //             outputExtensions: [\"travelTimes\", \"routeLengths\"],\n  //             waypointConstraints: {\n  //             originIndex: 0,\n  //             destinationIndex: 0,\n  //             },\n  //         },\n  //     };\n  //     fetch(URL, {\n  //     method: \"POST\",\n  //     headers: { \"Content-type\": \"application/json;charset=UTF-8\" },\n  //     body: JSON.stringify(data),\n  //     })\n  //     .then((response) => response.json())\n  //     .then((data) => {\n  //         const optimized_locations = data.summary.legSummaries.map((summary) => {\n  //             return { ...waypoints[summary.originIndex], ...summary };\n  //         });\n  //         console.log(optimized_locations);\n  //         optimized_locations.forEach((location, index) => {\n  //             const start_time = new Date(location.departureTime).toLocaleString();\n  //             const arrival_time = new Date(location.arrivalTime).toLocaleString();\n  //             const distance_in_seconds = location.travelTimeInSeconds\n  //             const start_at = location.originIndex;\n  //             const end_at = location.destinationIndex;\n  //             const popup = new tt.Popup({ offset: 50 }).setHTML(\n  //               `<div class=\"popup\">\n  //               <h1>Location ${index}</h1>\n  //               <br />\n  //               <p>Current Point: ${waypoints[start_at].name}</p>\n  //               <p>Departure Time: ${start_time}</p>\n  //               <p>Next Stop: ${waypoints[end_at].name}</p>\n  //               <p>Arrival Time:  ${arrival_time}<p>\n  //               <p>Distance To next stop:  ${location.lengthInMeters / 1000}(km)</p>\n  //               <p>Estimated Time To next stop:  ${\n  //                 distance_in_seconds.hours\n  //               } Hours, ${distance_in_seconds.minutes} Minutes</p>\n  //               </div> `\n  //             );\n  //             create_delivery_marker(location).setPopup(popup);\n  //         })\n  //         create_route(optimized_locations);\n  //     })\n  // };\n\n  // const create_route = async (locations) => {\n  //     await ttservices.services\n  //         .calculateRoute({\n  //         key: api_key,\n  //         locations,\n  //         })\n  //         .then((routeData) => {\n  //         const features = routeData.toGeoJson().features;\n  //         features.forEach((feature, index) => {\n  //             map.addLayer({\n  //             id: \"route\" + index,\n  //             type: \"line\",\n  //             source: {\n  //                 type: \"geojson\",\n  //                 data: feature,\n  //             },\n  //             paint: {\n  //                 \"line-color\": `red`,\n  //                 \"line-opacity\": 0.8,\n  //                 \"line-width\": 6,\n  //                 \"line-dasharray\": [1, 0, 1, 0],\n  //             }\n  //             });\n  //         });\n  //         });\n  // };\n\n  // function createAllRoutes(){\n  //     let pts_covered = 0;\n  //         while(pts_covered<waypoints.length){\n  //             create_route(waypoints.slice(pts_covered,Math.min(pts_covered+150,waypoints.length)))\n  //             pts_covered+=150    \n  //         }       \n  // }\n\n  function createRoute() {\n    console.log(currLocation);\n    var routeOptions = {\n      key: api_key,\n      locations: [[currLocation.lat, currLocation.lng], [deliveryLocation.lat, deliveryLocation.lng]]\n      //   travelMode: travel_mode,\n      //   vehicleCommercial: true,\n      //   vehicleHeading: 0,\n    };\n\n    ttservices.services.calculateRoute(routeOptions).then(function (response) {\n      //   routeOptions.locations.map((store) => \n      //      new tt.Marker().setLngLat(store).addTo(map.current)\n      //   );\n      var geojson = response.toGeoJson();\n      map.current.addLayer({\n        id: \"route\" + Math.random(100000),\n        type: \"line\",\n        source: {\n          type: \"geojson\",\n          data: geojson\n        },\n        paint: {\n          \"line-color\": \"#0f8ae2\",\n          \"line-width\": 8\n        }\n      });\n      var bounds = new tt.LngLatBounds();\n      geojson.features[0].geometry.coordinates.forEach(function (point) {\n        bounds.extend(tt.LngLat.convert(point)); // creates a bounding area\n      });\n\n      map.current.fitBounds(bounds, {\n        duration: 300,\n        padding: 50,\n        maxZoom: 14\n      }); // zooms the map to the searched route\n    });\n  }\n\n  useEffect(function () {\n    var map = tt.map({\n      key: api_key,\n      container: mapElement.current,\n      center: [77.5747463, 12.9140182],\n      zoom: zoom_level\n    });\n    map.addControl(new tt.FullscreenControl());\n    map.addControl(new tt.NavigationControl());\n    setMap(map);\n    return function () {\n      return map.remove();\n    };\n  }, []);\n  useEffect(function () {\n    if (map) {\n      map.on(\"load\", function () {\n        // for (let d in waypoints) {\n        //     create_delivery_marker(waypoints[d],map);\n        // }\n        createRoute();\n      });\n    } else {\n      console.log(\"error loading map\"); //Add better error handling function\n    }\n  }, [map]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"map_wrapper\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: mapElement,\n    className: \"mapDiv\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 234,\n      columnNumber: 9\n    }\n  }));\n}\nexport default Map;","map":{"version":3,"names":["React","ttservices","tt","useEffect","useState","useRef","api_key","axios","getSnapFunction","get","then","res","console","log","data","route","forEach","item","map","addLayer","id","Math","random","toString","type","source","features","geometry","properties","coordinates","layout","paint","setCenter","parseFloat","catch","err","Map","currLocation","deliveryLocation","destinations","zoom_level","travel_mode","mapElement","setMap","waypoints","setWayPoints","create_delivery_marker","location","marker_el","document","createElement","className","marker","Marker","element","anchor","setLngLat","lng","lat","addTo","URL","createRoute","routeOptions","key","locations","services","calculateRoute","response","geojson","toGeoJson","current","bounds","LngLatBounds","point","extend","LngLat","convert","fitBounds","duration","padding","maxZoom","container","center","zoom","addControl","FullscreenControl","NavigationControl","remove","on"],"sources":["/home/krishnansh/Documents/WebDev/PS/tom-tom-app/src/Map.js"],"sourcesContent":["import React from 'react'\nimport \"@tomtom-international/web-sdk-maps/dist/maps.css\";\nimport * as ttservices from \"@tomtom-international/web-sdk-services\";\nimport tt from \"@tomtom-international/web-sdk-maps\";\nimport { useEffect, useState, useRef } from \"react\";\n// import { fromSeconds } from \"from-seconds\";\nimport { api_key } from \"./constants.js\"\nimport axios from \"axios\"\n\nconst getSnapFunction = () => {\n    axios.get(\"https://api.tomtom.com/snap-to-roads/1/snap-to-roads?points=4.6104,52.3757;4.6140,52.393&fields={projectedPoints{type,geometry{type,coordinates},properties{routeIndex}},route{type,geometry{type,coordinates},properties{id,speedRestrictions{maximumSpeed{value,unit}}}}}&key=8h504Wc4AXL6OPndqhrtKf70AovVBL3V\").then((res) => \n    {\n     console.log(res.data)\n     res.data.route.forEach(\n      (item) => {\n        map.addLayer({\n          id: Math.random().toString(),\n          type: \"line\",\n          source: {\n            type: \"geojson\",\n            data: {\n              type: \"FeatureCollection\",\n              features: [\n                {\n                  type: \"Feature\",\n                  geometry: {\n                    type: \"LineString\",\n                    properties: {},\n                    coordinates: item.geometry.coordinates\n                  }\n                }\n              ]\n            }\n          },\n          layout: {\n            \"line-cap\": \"round\",\n            \"line-join\": \"round\"\n          },\n          paint: {\n            \"line-color\": \"#ff0000\",\n            \"line-width\": 2\n          }\n        });\n      }\n     )\n       map.setCenter([parseFloat(4.6104), parseFloat(52.3757)]);\n   }).catch((err) => console.log(err))\n  }\nfunction Map({ currLocation, deliveryLocation, destinations, zoom_level, travel_mode }) {\n\n    const mapElement = useRef();\n    const [map, setMap] = useState(null);\n    const [waypoints,setWayPoints] = useState(destinations);\n\n    function create_delivery_marker(location) {\n        const marker_el = document.createElement(\"div\");\n        marker_el.className = 'marker-delivery';\n        // const popup = new tt.Popup({ offset: 20 }).setText(location.name);\n        const marker = new tt.Marker({ element: marker_el, anchor: \"bottom\" })\n        .setLngLat([location.lng, location.lat])\n        .addTo(map);\n\n        return marker;\n    }\n    let URL = `https://api.tomtom.com/routing/waypointoptimization/1?key=${api_key}`;\n    // const optimize_routes = () => {\n    //     const data = {\n    //         waypoints: waypoints.map((location) => {\n    //             return {\n    //             point: {\n    //                 latitude: location.lat,\n    //                 longitude: location.lng,\n    //             },\n    //             };\n    //         }),\n    //         options: {\n    //             travelMode: travel_mode,\n    //             vehicleMaxSpeed: 0,\n    //             vehicleCommercial: true,\n    //             vehicleLoadType: [\"otherHazmatGeneral\"],\n    //             traffic: \"live\",\n    //             departAt: \"now\",\n    //             outputExtensions: [\"travelTimes\", \"routeLengths\"],\n    //             waypointConstraints: {\n    //             originIndex: 0,\n    //             destinationIndex: 0,\n    //             },\n    //         },\n    //     };\n    //     fetch(URL, {\n    //     method: \"POST\",\n    //     headers: { \"Content-type\": \"application/json;charset=UTF-8\" },\n    //     body: JSON.stringify(data),\n    //     })\n    //     .then((response) => response.json())\n    //     .then((data) => {\n    //         const optimized_locations = data.summary.legSummaries.map((summary) => {\n    //             return { ...waypoints[summary.originIndex], ...summary };\n    //         });\n    //         console.log(optimized_locations);\n    //         optimized_locations.forEach((location, index) => {\n    //             const start_time = new Date(location.departureTime).toLocaleString();\n    //             const arrival_time = new Date(location.arrivalTime).toLocaleString();\n    //             const distance_in_seconds = location.travelTimeInSeconds\n    //             const start_at = location.originIndex;\n    //             const end_at = location.destinationIndex;\n    //             const popup = new tt.Popup({ offset: 50 }).setHTML(\n    //               `<div class=\"popup\">\n    //               <h1>Location ${index}</h1>\n    //               <br />\n    //               <p>Current Point: ${waypoints[start_at].name}</p>\n    //               <p>Departure Time: ${start_time}</p>\n    //               <p>Next Stop: ${waypoints[end_at].name}</p>\n    //               <p>Arrival Time:  ${arrival_time}<p>\n    //               <p>Distance To next stop:  ${location.lengthInMeters / 1000}(km)</p>\n    //               <p>Estimated Time To next stop:  ${\n    //                 distance_in_seconds.hours\n    //               } Hours, ${distance_in_seconds.minutes} Minutes</p>\n    //               </div> `\n    //             );\n    //             create_delivery_marker(location).setPopup(popup);\n    //         })\n    //         create_route(optimized_locations);\n    //     })\n    // };\n\n    // const create_route = async (locations) => {\n    //     await ttservices.services\n    //         .calculateRoute({\n    //         key: api_key,\n    //         locations,\n    //         })\n    //         .then((routeData) => {\n    //         const features = routeData.toGeoJson().features;\n    //         features.forEach((feature, index) => {\n    //             map.addLayer({\n    //             id: \"route\" + index,\n    //             type: \"line\",\n    //             source: {\n    //                 type: \"geojson\",\n    //                 data: feature,\n    //             },\n    //             paint: {\n    //                 \"line-color\": `red`,\n    //                 \"line-opacity\": 0.8,\n    //                 \"line-width\": 6,\n    //                 \"line-dasharray\": [1, 0, 1, 0],\n    //             }\n    //             });\n    //         });\n    //         });\n    // };\n\n    // function createAllRoutes(){\n    //     let pts_covered = 0;\n    //         while(pts_covered<waypoints.length){\n    //             create_route(waypoints.slice(pts_covered,Math.min(pts_covered+150,waypoints.length)))\n    //             pts_covered+=150    \n    //         }       \n    // }\n\n    function createRoute () {\n        console.log(currLocation)\n        const routeOptions = {\n          key: api_key,\n          locations: [\n            [currLocation.lat, currLocation.lng],\n            [deliveryLocation.lat, deliveryLocation.lng],\n          ],\n        //   travelMode: travel_mode,\n        //   vehicleCommercial: true,\n        //   vehicleHeading: 0,\n        };\n     \n        ttservices.services.calculateRoute(routeOptions).then((response) => {\n        //   routeOptions.locations.map((store) => \n        //      new tt.Marker().setLngLat(store).addTo(map.current)\n        //   );\n          var geojson = response.toGeoJson();\n          map.current.addLayer({\n            id: \"route\" + Math.random(100000),\n            type: \"line\",\n            source: {\n              type: \"geojson\",\n              data: geojson,\n            },\n            paint: {\n              \"line-color\": \"#0f8ae2\",\n              \"line-width\": 8,\n            },\n          });\n     \n          var bounds = new tt.LngLatBounds();\n          geojson.features[0].geometry.coordinates.forEach(function (point) {\n            bounds.extend(tt.LngLat.convert(point)); // creates a bounding area\n          });\n          map.current.fitBounds(bounds, {\n            duration: 300,\n            padding: 50,\n            maxZoom: 14,\n          }); // zooms the map to the searched route\n        });\n    }\n\n    useEffect(() => {\n        let map = tt.map({\n        key: api_key,\n        container: mapElement.current,\n        center: [77.5747463,12.9140182],\n        zoom: zoom_level,\n        });\n        map.addControl(new tt.FullscreenControl());\n        map.addControl(new tt.NavigationControl());\n        setMap(map);\n        return () => map.remove();\n    }, []);\n    \n    useEffect(() => {\n        if (map) {\n          map.on(\"load\", () => {\n            // for (let d in waypoints) {\n            //     create_delivery_marker(waypoints[d],map);\n            // }\n            createRoute()\n          });\n        }\n        else{\n            console.log(\"error loading map\"); //Add better error handling function\n        }\n      }, [map]);\n\n    return (\n      <div className=\"map_wrapper\">\n        <div ref={mapElement} className=\"mapDiv\" />\n      </div>\n    );\n  }\n  export default Map;"],"mappings":";;AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,OAAO,kDAAkD;AACzD,OAAO,KAAKC,UAAU,MAAM,wCAAwC;AACpE,OAAOC,EAAE,MAAM,oCAAoC;AACnD,SAASC,SAAS,EAAEC,QAAQ,EAAEC,MAAM,QAAQ,OAAO;AACnD;AACA,SAASC,OAAO,QAAQ,gBAAgB;AACxC,OAAOC,KAAK,MAAM,OAAO;AAEzB,IAAMC,eAAe,GAAG,SAAlBA,eAAe,GAAS;EAC1BD,KAAK,CAACE,GAAG,CAAC,kTAAkT,CAAC,CAACC,IAAI,CAAC,UAACC,GAAG,EACvU;IACCC,OAAO,CAACC,GAAG,CAACF,GAAG,CAACG,IAAI,CAAC;IACrBH,GAAG,CAACG,IAAI,CAACC,KAAK,CAACC,OAAO,CACrB,UAACC,IAAI,EAAK;MACRC,GAAG,CAACC,QAAQ,CAAC;QACXC,EAAE,EAAEC,IAAI,CAACC,MAAM,EAAE,CAACC,QAAQ,EAAE;QAC5BC,IAAI,EAAE,MAAM;QACZC,MAAM,EAAE;UACND,IAAI,EAAE,SAAS;UACfV,IAAI,EAAE;YACJU,IAAI,EAAE,mBAAmB;YACzBE,QAAQ,EAAE,CACR;cACEF,IAAI,EAAE,SAAS;cACfG,QAAQ,EAAE;gBACRH,IAAI,EAAE,YAAY;gBAClBI,UAAU,EAAE,CAAC,CAAC;gBACdC,WAAW,EAAEZ,IAAI,CAACU,QAAQ,CAACE;cAC7B;YACF,CAAC;UAEL;QACF,CAAC;QACDC,MAAM,EAAE;UACN,UAAU,EAAE,OAAO;UACnB,WAAW,EAAE;QACf,CAAC;QACDC,KAAK,EAAE;UACL,YAAY,EAAE,SAAS;UACvB,YAAY,EAAE;QAChB;MACF,CAAC,CAAC;IACJ,CAAC,CACD;IACCb,GAAG,CAACc,SAAS,CAAC,CAACC,UAAU,CAAC,MAAM,CAAC,EAAEA,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC;EAC5D,CAAC,CAAC,CAACC,KAAK,CAAC,UAACC,GAAG;IAAA,OAAKvB,OAAO,CAACC,GAAG,CAACsB,GAAG,CAAC;EAAA,EAAC;AACpC,CAAC;AACH,SAASC,GAAG,OAA4E;EAAA,IAAzEC,YAAY,QAAZA,YAAY;IAAEC,gBAAgB,QAAhBA,gBAAgB;IAAEC,YAAY,QAAZA,YAAY;IAAEC,UAAU,QAAVA,UAAU;IAAEC,WAAW,QAAXA,WAAW;EAEhF,IAAMC,UAAU,GAAGrC,MAAM,EAAE;EAAC,gBACND,QAAQ,CAAC,IAAI,CAAC;IAAA;IAA7Bc,GAAG;IAAEyB,MAAM;EAAA,iBACevC,QAAQ,CAACmC,YAAY,CAAC;IAAA;IAAhDK,SAAS;IAACC,YAAY;EAE7B,SAASC,sBAAsB,CAACC,QAAQ,EAAE;IACtC,IAAMC,SAAS,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC/CF,SAAS,CAACG,SAAS,GAAG,iBAAiB;IACvC;IACA,IAAMC,MAAM,GAAG,IAAIlD,EAAE,CAACmD,MAAM,CAAC;MAAEC,OAAO,EAAEN,SAAS;MAAEO,MAAM,EAAE;IAAS,CAAC,CAAC,CACrEC,SAAS,CAAC,CAACT,QAAQ,CAACU,GAAG,EAAEV,QAAQ,CAACW,GAAG,CAAC,CAAC,CACvCC,KAAK,CAACzC,GAAG,CAAC;IAEX,OAAOkC,MAAM;EACjB;EACA,IAAIQ,GAAG,uEAAgEtD,OAAO,CAAE;EAChF;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,SAASuD,WAAW,GAAI;IACpBjD,OAAO,CAACC,GAAG,CAACwB,YAAY,CAAC;IACzB,IAAMyB,YAAY,GAAG;MACnBC,GAAG,EAAEzD,OAAO;MACZ0D,SAAS,EAAE,CACT,CAAC3B,YAAY,CAACqB,GAAG,EAAErB,YAAY,CAACoB,GAAG,CAAC,EACpC,CAACnB,gBAAgB,CAACoB,GAAG,EAAEpB,gBAAgB,CAACmB,GAAG,CAAC;MAEhD;MACA;MACA;IACA,CAAC;;IAEDxD,UAAU,CAACgE,QAAQ,CAACC,cAAc,CAACJ,YAAY,CAAC,CAACpD,IAAI,CAAC,UAACyD,QAAQ,EAAK;MACpE;MACA;MACA;MACE,IAAIC,OAAO,GAAGD,QAAQ,CAACE,SAAS,EAAE;MAClCnD,GAAG,CAACoD,OAAO,CAACnD,QAAQ,CAAC;QACnBC,EAAE,EAAE,OAAO,GAAGC,IAAI,CAACC,MAAM,CAAC,MAAM,CAAC;QACjCE,IAAI,EAAE,MAAM;QACZC,MAAM,EAAE;UACND,IAAI,EAAE,SAAS;UACfV,IAAI,EAAEsD;QACR,CAAC;QACDrC,KAAK,EAAE;UACL,YAAY,EAAE,SAAS;UACvB,YAAY,EAAE;QAChB;MACF,CAAC,CAAC;MAEF,IAAIwC,MAAM,GAAG,IAAIrE,EAAE,CAACsE,YAAY,EAAE;MAClCJ,OAAO,CAAC1C,QAAQ,CAAC,CAAC,CAAC,CAACC,QAAQ,CAACE,WAAW,CAACb,OAAO,CAAC,UAAUyD,KAAK,EAAE;QAChEF,MAAM,CAACG,MAAM,CAACxE,EAAE,CAACyE,MAAM,CAACC,OAAO,CAACH,KAAK,CAAC,CAAC,CAAC,CAAC;MAC3C,CAAC,CAAC;;MACFvD,GAAG,CAACoD,OAAO,CAACO,SAAS,CAACN,MAAM,EAAE;QAC5BO,QAAQ,EAAE,GAAG;QACbC,OAAO,EAAE,EAAE;QACXC,OAAO,EAAE;MACX,CAAC,CAAC,CAAC,CAAC;IACN,CAAC,CAAC;EACN;;EAEA7E,SAAS,CAAC,YAAM;IACZ,IAAIe,GAAG,GAAGhB,EAAE,CAACgB,GAAG,CAAC;MACjB6C,GAAG,EAAEzD,OAAO;MACZ2E,SAAS,EAAEvC,UAAU,CAAC4B,OAAO;MAC7BY,MAAM,EAAE,CAAC,UAAU,EAAC,UAAU,CAAC;MAC/BC,IAAI,EAAE3C;IACN,CAAC,CAAC;IACFtB,GAAG,CAACkE,UAAU,CAAC,IAAIlF,EAAE,CAACmF,iBAAiB,EAAE,CAAC;IAC1CnE,GAAG,CAACkE,UAAU,CAAC,IAAIlF,EAAE,CAACoF,iBAAiB,EAAE,CAAC;IAC1C3C,MAAM,CAACzB,GAAG,CAAC;IACX,OAAO;MAAA,OAAMA,GAAG,CAACqE,MAAM,EAAE;IAAA;EAC7B,CAAC,EAAE,EAAE,CAAC;EAENpF,SAAS,CAAC,YAAM;IACZ,IAAIe,GAAG,EAAE;MACPA,GAAG,CAACsE,EAAE,CAAC,MAAM,EAAE,YAAM;QACnB;QACA;QACA;QACA3B,WAAW,EAAE;MACf,CAAC,CAAC;IACJ,CAAC,MACG;MACAjD,OAAO,CAACC,GAAG,CAAC,mBAAmB,CAAC,CAAC,CAAC;IACtC;EACF,CAAC,EAAE,CAACK,GAAG,CAAC,CAAC;EAEX,oBACE;IAAK,SAAS,EAAC,aAAa;IAAA;IAAA;MAAA;MAAA;MAAA;IAAA;EAAA,gBAC1B;IAAK,GAAG,EAAEwB,UAAW;IAAC,SAAS,EAAC,QAAQ;IAAA;IAAA;MAAA;MAAA;MAAA;IAAA;EAAA,EAAG,CACvC;AAEV;AACA,eAAeN,GAAG"},"metadata":{},"sourceType":"module"}