{"ast":null,"code":"'use strict';\n\n/**\n * Module dependencies\n */\nvar util = require('util');\nvar braces = require('braces');\nvar toRegex = require('to-regex');\nvar extend = require('extend-shallow');\n\n/**\n * Local dependencies\n */\n\nvar compilers = require('./lib/compilers');\nvar parsers = require('./lib/parsers');\nvar cache = require('./lib/cache');\nvar utils = require('./lib/utils');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var mm = require('micromatch');\n * mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n  while (++idx < len) {\n    var pattern = patterns[idx];\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.match(list, pattern[, options]);\n *\n * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nmicromatch.match = function (list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, micromatch.matcher);\n  var matches = [];\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n  while (++idx < len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = micromatch.not(matches, options.ignore, options);\n  }\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.isMatch(string, pattern[, options]);\n *\n * console.log(mm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(mm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nmicromatch.isMatch = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (isEmptyString(str) || isEmptyString(pattern)) {\n    return false;\n  }\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = function (list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.any(string, patterns[, options]);\n *\n * console.log(mm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(mm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.any = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (isEmptyString(str) || isEmptyString(patterns)) {\n    return false;\n  }\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    if (micromatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    if (!micromatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = function (list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n  var unixify = utils.unixify(opts);\n  list = utils.arrayify(list).map(unixify);\n  var matches = utils.diff(list, micromatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, micromatch(list, ignore));\n  }\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = function (str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (typeof patterns === 'string') {\n    if (isEmptyString(str) || isEmptyString(patterns)) {\n      return false;\n    }\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n  var opts = extend({}, options, {\n    contains: true\n  });\n  return micromatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nmicromatch.matchBase = function (pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = function (obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matcher(pattern[, options]);\n *\n * var isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = function matcher(pattern, options) {\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = micromatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (micromatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n    return function (str) {\n      if (equals(str)) {\n        return true;\n      }\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n  var fn = test(re);\n  Object.defineProperty(fn, 'result', {\n    configurable: true,\n    enumerable: false,\n    value: re.result\n  });\n  return fn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = function (pattern, str, options) {\n  var re = micromatch.makeRe(pattern, extend({\n    capture: true\n  }, options));\n  var unixify = utils.unixify(options);\n  function match() {\n    return function (string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n      return match.slice(1);\n    };\n  }\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n  function makeRe() {\n    var result = micromatch.create(pattern, options);\n    var ast_array = [];\n    var output = result.map(function (obj) {\n      obj.ast.state = obj.state;\n      ast_array.push(obj.ast);\n      return obj.output;\n    });\n    var regex = toRegex(output.join('|'), options);\n    Object.defineProperty(regex, 'result', {\n      configurable: true,\n      enumerable: false,\n      value: ast_array\n    });\n    return regex;\n  }\n  return memoize('makeRe', pattern, options, makeRe);\n};\n\n/**\n * Expand the given brace `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * console.log(mm.braces('foo/{a,b}/bar'));\n * //=> ['foo/(a|b)/bar']\n *\n * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));\n * //=> ['foo/(a|b)/bar']\n * ```\n * @param {String} `pattern` String with brace pattern to expand.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = function (pattern, options) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be an array or string');\n  }\n  function expand() {\n    if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n      return utils.arrayify(pattern);\n    }\n    return braces(pattern, options);\n  }\n  return memoize('braces', pattern, options, expand);\n};\n\n/**\n * Proxy to the [micromatch.braces](#method), for parity with\n * minimatch.\n */\n\nmicromatch.braceExpand = function (pattern, options) {\n  var opts = extend({}, options, {\n    expand: true\n  });\n  return micromatch.braces(pattern, opts);\n};\n\n/**\n * Parses the given glob `pattern` and returns an array of abstract syntax\n * trees (ASTs), with the compiled `output` and optional source `map` on\n * each AST.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.create(pattern[, options]);\n *\n * console.log(mm.create('abc/*.js'));\n * // [{ options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }]\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nmicromatch.create = function (pattern, options) {\n  return memoize('create', pattern, options, function () {\n    function create(str, opts) {\n      return micromatch.compile(micromatch.parse(str, opts), opts);\n    }\n    pattern = micromatch.braces(pattern, options);\n    var len = pattern.length;\n    var idx = -1;\n    var res = [];\n    while (++idx < len) {\n      res.push(create(pattern[idx], options));\n    }\n    return res;\n  });\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.parse(pattern[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nmicromatch.parse = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n  return memoize('parse', pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.compile(ast[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(mm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nmicromatch.compile = function (ast, options) {\n  if (typeof ast === 'string') {\n    ast = micromatch.parse(ast, options);\n  }\n  return memoize('compile', ast.input, options, function () {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  });\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * mm.clearCache();\n * ```\n * @api public\n */\n\nmicromatch.clearCache = function () {\n  micromatch.cache.caches = {};\n};\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nfunction isEmptyString(val) {\n  return String(val) === '' || String(val) === './';\n}\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n  return memoize('compose', String(patterns), options, function () {\n    return function (file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `micromatch`\n */\n\nmicromatch.compilers = compilers;\nmicromatch.parsers = parsers;\nmicromatch.caches = cache.caches;\n\n/**\n * Expose `micromatch`\n * @type {Function}\n */\n\nmodule.exports = micromatch;","map":{"version":3,"names":["util","require","braces","toRegex","extend","compilers","parsers","cache","utils","MAX_LENGTH","micromatch","list","patterns","options","arrayify","len","length","match","omit","keep","idx","pattern","charCodeAt","push","apply","slice","matches","diff","nodupes","unique","Array","isArray","TypeError","unixify","isMatch","memoize","matcher","ele","value","failglob","Error","nonull","nullglob","unescape","ignore","not","str","inspect","isEmptyString","equals","equalsPattern","some","i","every","any","all","opts","map","contains","containsPattern","matchBase","indexOf","basename","matchKeys","obj","isObject","keys","Object","pick","compose","RegExp","test","isString","hasSpecialChars","nocase","toLowerCase","matchPath","re","makeRe","matchBasename","regex","fn","defineProperty","configurable","enumerable","result","capture","string","exec","create","ast_array","output","ast","state","join","expand","nobrace","braceExpand","compile","parse","res","snapdragon","instantiate","define","input","clearCache","caches","val","String","matchers","file","type","key","createKey","has","get","set","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/micromatch/index.js"],"sourcesContent":["'use strict';\n\n/**\n * Module dependencies\n */\n\nvar util = require('util');\nvar braces = require('braces');\nvar toRegex = require('to-regex');\nvar extend = require('extend-shallow');\n\n/**\n * Local dependencies\n */\n\nvar compilers = require('./lib/compilers');\nvar parsers = require('./lib/parsers');\nvar cache = require('./lib/cache');\nvar utils = require('./lib/utils');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * The main function takes a list of strings and one or more\n * glob patterns to use for matching.\n *\n * ```js\n * var mm = require('micromatch');\n * mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {Array} `list` A list of strings to match\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nfunction micromatch(list, patterns, options) {\n  patterns = utils.arrayify(patterns);\n  list = utils.arrayify(list);\n\n  var len = patterns.length;\n  if (list.length === 0 || len === 0) {\n    return [];\n  }\n\n  if (len === 1) {\n    return micromatch.match(list, patterns[0], options);\n  }\n\n  var omit = [];\n  var keep = [];\n  var idx = -1;\n\n  while (++idx < len) {\n    var pattern = patterns[idx];\n\n    if (typeof pattern === 'string' && pattern.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, micromatch.match(list, pattern.slice(1), options));\n    } else {\n      keep.push.apply(keep, micromatch.match(list, pattern, options));\n    }\n  }\n\n  var matches = utils.diff(keep, omit);\n  if (!options || options.nodupes !== false) {\n    return utils.unique(matches);\n  }\n\n  return matches;\n}\n\n/**\n * Similar to the main function, but `pattern` must be a string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.match(list, pattern[, options]);\n *\n * console.log(mm.match(['a.a', 'a.aa', 'a.b', 'a.c'], '*.a'));\n * //=> ['a.a', 'a.aa']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nmicromatch.match = function(list, pattern, options) {\n  if (Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  var unixify = utils.unixify(options);\n  var isMatch = memoize('match', pattern, options, micromatch.matcher);\n  var matches = [];\n\n  list = utils.arrayify(list);\n  var len = list.length;\n  var idx = -1;\n\n  while (++idx < len) {\n    var ele = list[idx];\n    if (ele === pattern || isMatch(ele)) {\n      matches.push(utils.value(ele, unixify, options));\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === 'undefined') {\n    return utils.unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [options.unescape ? utils.unescape(pattern) : pattern];\n    }\n  }\n\n  // if `opts.ignore` was defined, diff ignored list\n  if (options.ignore) {\n    matches = micromatch.not(matches, options.ignore, options);\n  }\n\n  return options.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.isMatch(string, pattern[, options]);\n *\n * console.log(mm.isMatch('a.a', '*.a'));\n * //=> true\n * console.log(mm.isMatch('a.b', '*.a'));\n * //=> false\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the string matches the glob pattern.\n * @api public\n */\n\nmicromatch.isMatch = function(str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(pattern)) {\n    return false;\n  }\n\n  var equals = utils.equalsPattern(options);\n  if (equals(str)) {\n    return true;\n  }\n\n  var isMatch = memoize('isMatch', pattern, options, micromatch.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the\n * given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length === 1) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param  {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = function(list, patterns, options) {\n  if (typeof list === 'string') {\n    list = [list];\n  }\n  for (var i = 0; i < list.length; i++) {\n    if (micromatch(list[i], patterns, options).length !== 1) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **any** of the given glob `patterns`\n * match the specified `string`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.any(string, patterns[, options]);\n *\n * console.log(mm.any('a.a', ['b.*', '*.a']));\n * //=> true\n * console.log(mm.any('a.a', 'b.*'));\n * //=> false\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.any = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (isEmptyString(str) || isEmptyString(patterns)) {\n    return false;\n  }\n\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n\n  for (var i = 0; i < patterns.length; i++) {\n    if (micromatch.isMatch(str, patterns[i], options)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param  {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n  if (typeof patterns === 'string') {\n    patterns = [patterns];\n  }\n  for (var i = 0; i < patterns.length; i++) {\n    if (!micromatch.isMatch(str, patterns[i], options)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = function(list, patterns, options) {\n  var opts = extend({}, options);\n  var ignore = opts.ignore;\n  delete opts.ignore;\n\n  var unixify = utils.unixify(opts);\n  list = utils.arrayify(list).map(unixify);\n\n  var matches = utils.diff(list, micromatch(list, patterns, opts));\n  if (ignore) {\n    matches = utils.diff(matches, micromatch(list, ignore));\n  }\n\n  return opts.nodupes !== false ? utils.unique(matches) : matches;\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = function(str, patterns, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string: \"' + util.inspect(str) + '\"');\n  }\n\n  if (typeof patterns === 'string') {\n    if (isEmptyString(str) || isEmptyString(patterns)) {\n      return false;\n    }\n\n    var equals = utils.equalsPattern(patterns, options);\n    if (equals(str)) {\n      return true;\n    }\n    var contains = utils.containsPattern(patterns, options);\n    if (contains(str)) {\n      return true;\n    }\n  }\n\n  var opts = extend({}, options, {contains: true});\n  return micromatch.any(str, patterns, opts);\n};\n\n/**\n * Returns true if the given pattern and options should enable\n * the `matchBase` option.\n * @return {Boolean}\n * @api private\n */\n\nmicromatch.matchBase = function(pattern, options) {\n  if (pattern && pattern.indexOf('/') !== -1 || !options) return false;\n  return options.basename === true || options.matchBase === true;\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matchKeys(object, patterns[, options]);\n *\n * var obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = function(obj, patterns, options) {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('expected the first argument to be an object');\n  }\n  var keys = micromatch(Object.keys(obj), patterns, options);\n  return utils.pick(obj, keys);\n};\n\n/**\n * Returns a memoized matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.matcher(pattern[, options]);\n *\n * var isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = function matcher(pattern, options) {\n  if (Array.isArray(pattern)) {\n    return compose(pattern, options, matcher);\n  }\n\n  // if pattern is a regex\n  if (pattern instanceof RegExp) {\n    return test(pattern);\n  }\n\n  // if pattern is invalid\n  if (!utils.isString(pattern)) {\n    throw new TypeError('expected pattern to be an array, string or regex');\n  }\n\n  // if pattern is a non-glob string\n  if (!utils.hasSpecialChars(pattern)) {\n    if (options && options.nocase === true) {\n      pattern = pattern.toLowerCase();\n    }\n    return utils.matchPath(pattern, options);\n  }\n\n  // if pattern is a glob string\n  var re = micromatch.makeRe(pattern, options);\n\n  // if `options.matchBase` or `options.basename` is defined\n  if (micromatch.matchBase(pattern, options)) {\n    return utils.matchBasename(re, options);\n  }\n\n  function test(regex) {\n    var equals = utils.equalsPattern(options);\n    var unixify = utils.unixify(options);\n\n    return function(str) {\n      if (equals(str)) {\n        return true;\n      }\n\n      if (regex.test(unixify(str))) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  var fn = test(re);\n  Object.defineProperty(fn, 'result', {\n    configurable: true,\n    enumerable: false,\n    value: re.result\n  });\n  return fn;\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = function(pattern, str, options) {\n  var re = micromatch.makeRe(pattern, extend({capture: true}, options));\n  var unixify = utils.unixify(options);\n\n  function match() {\n    return function(string) {\n      var match = re.exec(unixify(string));\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = memoize('capture', pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed.\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var result = micromatch.create(pattern, options);\n    var ast_array = [];\n    var output = result.map(function(obj) {\n      obj.ast.state = obj.state;\n      ast_array.push(obj.ast);\n      return obj.output;\n    });\n\n    var regex = toRegex(output.join('|'), options);\n    Object.defineProperty(regex, 'result', {\n      configurable: true,\n      enumerable: false,\n      value: ast_array\n    });\n    return regex;\n  }\n\n  return memoize('makeRe', pattern, options, makeRe);\n};\n\n/**\n * Expand the given brace `pattern`.\n *\n * ```js\n * var mm = require('micromatch');\n * console.log(mm.braces('foo/{a,b}/bar'));\n * //=> ['foo/(a|b)/bar']\n *\n * console.log(mm.braces('foo/{a,b}/bar', {expand: true}));\n * //=> ['foo/(a|b)/bar']\n * ```\n * @param {String} `pattern` String with brace pattern to expand.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = function(pattern, options) {\n  if (typeof pattern !== 'string' && !Array.isArray(pattern)) {\n    throw new TypeError('expected pattern to be an array or string');\n  }\n\n  function expand() {\n    if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n      return utils.arrayify(pattern);\n    }\n    return braces(pattern, options);\n  }\n\n  return memoize('braces', pattern, options, expand);\n};\n\n/**\n * Proxy to the [micromatch.braces](#method), for parity with\n * minimatch.\n */\n\nmicromatch.braceExpand = function(pattern, options) {\n  var opts = extend({}, options, {expand: true});\n  return micromatch.braces(pattern, opts);\n};\n\n/**\n * Parses the given glob `pattern` and returns an array of abstract syntax\n * trees (ASTs), with the compiled `output` and optional source `map` on\n * each AST.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.create(pattern[, options]);\n *\n * console.log(mm.create('abc/*.js'));\n * // [{ options: { source: 'string', sourcemap: true },\n * //   state: {},\n * //   compilers:\n * //    { ... },\n * //   output: '(\\\\.[\\\\\\\\\\\\/])?abc\\\\/(?!\\\\.)(?=.)[^\\\\/]*?\\\\.js',\n * //   ast:\n * //    { type: 'root',\n * //      errors: [],\n * //      nodes:\n * //       [ ... ],\n * //      dot: false,\n * //      input: 'abc/*.js' },\n * //   parsingErrors: [],\n * //   map:\n * //    { version: 3,\n * //      sources: [ 'string' ],\n * //      names: [],\n * //      mappings: 'AAAA,GAAG,EAAC,kBAAC,EAAC,EAAE',\n * //      sourcesContent: [ 'abc/*.js' ] },\n * //   position: { line: 1, column: 28 },\n * //   content: {},\n * //   files: {},\n * //   idx: 6 }]\n * ```\n * @param {String} `pattern` Glob pattern to parse and compile.\n * @param {Object} `options` Any [options](#options) to change how parsing and compiling is performed.\n * @return {Object} Returns an object with the parsed AST, compiled string and optional source map.\n * @api public\n */\n\nmicromatch.create = function(pattern, options) {\n  return memoize('create', pattern, options, function() {\n    function create(str, opts) {\n      return micromatch.compile(micromatch.parse(str, opts), opts);\n    }\n\n    pattern = micromatch.braces(pattern, options);\n    var len = pattern.length;\n    var idx = -1;\n    var res = [];\n\n    while (++idx < len) {\n      res.push(create(pattern[idx], options));\n    }\n    return res;\n  });\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.parse(pattern[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(ast);\n * // { type: 'root',\n * //   errors: [],\n * //   input: 'a/{b,c}/d',\n * //   nodes:\n * //    [ { type: 'bos', val: '' },\n * //      { type: 'text', val: 'a/' },\n * //      { type: 'brace',\n * //        nodes:\n * //         [ { type: 'brace.open', val: '{' },\n * //           { type: 'text', val: 'b,c' },\n * //           { type: 'brace.close', val: '}' } ] },\n * //      { type: 'text', val: '/d' },\n * //      { type: 'eos', val: '' } ] }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an AST\n * @api public\n */\n\nmicromatch.parse = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  function parse() {\n    var snapdragon = utils.instantiate(null, options);\n    parsers(snapdragon, options);\n\n    var ast = snapdragon.parse(pattern, options);\n    utils.define(ast, 'snapdragon', snapdragon);\n    ast.input = pattern;\n    return ast;\n  }\n\n  return memoize('parse', pattern, options, parse);\n};\n\n/**\n * Compile the given `ast` or string with the given `options`.\n *\n * ```js\n * var mm = require('micromatch');\n * mm.compile(ast[, options]);\n *\n * var ast = mm.parse('a/{b,c}/d');\n * console.log(mm.compile(ast));\n * // { options: { source: 'string' },\n * //   state: {},\n * //   compilers:\n * //    { eos: [Function],\n * //      noop: [Function],\n * //      bos: [Function],\n * //      brace: [Function],\n * //      'brace.open': [Function],\n * //      text: [Function],\n * //      'brace.close': [Function] },\n * //   output: [ 'a/(b|c)/d' ],\n * //   ast:\n * //    { ... },\n * //   parsingErrors: [] }\n * ```\n * @param {Object|String} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object that has an `output` property with the compiled string.\n * @api public\n */\n\nmicromatch.compile = function(ast, options) {\n  if (typeof ast === 'string') {\n    ast = micromatch.parse(ast, options);\n  }\n\n  return memoize('compile', ast.input, options, function() {\n    var snapdragon = utils.instantiate(ast, options);\n    compilers(snapdragon, options);\n    return snapdragon.compile(ast, options);\n  });\n};\n\n/**\n * Clear the regex cache.\n *\n * ```js\n * mm.clearCache();\n * ```\n * @api public\n */\n\nmicromatch.clearCache = function() {\n  micromatch.cache.caches = {};\n};\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nfunction isEmptyString(val) {\n  return String(val) === '' || String(val) === './';\n}\n\n/**\n * Compose a matcher function with the given patterns.\n * This allows matcher functions to be compiled once and\n * called multiple times.\n */\n\nfunction compose(patterns, options, matcher) {\n  var matchers;\n\n  return memoize('compose', String(patterns), options, function() {\n    return function(file) {\n      // delay composition until it's invoked the first time,\n      // after that it won't be called again\n      if (!matchers) {\n        matchers = [];\n        for (var i = 0; i < patterns.length; i++) {\n          matchers.push(matcher(patterns[i], options));\n        }\n      }\n\n      var len = matchers.length;\n      while (len--) {\n        if (matchers[len](file) === true) {\n          return true;\n        }\n      }\n      return false;\n    };\n  });\n}\n\n/**\n * Memoize a generated regex or function. A unique key is generated\n * from the `type` (usually method name), the `pattern`, and\n * user-defined options.\n */\n\nfunction memoize(type, pattern, options, fn) {\n  var key = utils.createKey(type + '=' + pattern, options);\n\n  if (options && options.cache === false) {\n    return fn(pattern, options);\n  }\n\n  if (cache.has(type, key)) {\n    return cache.get(type, key);\n  }\n\n  var val = fn(pattern, options);\n  cache.set(type, key, val);\n  return val;\n}\n\n/**\n * Expose compiler, parser and cache on `micromatch`\n */\n\nmicromatch.compilers = compilers;\nmicromatch.parsers = parsers;\nmicromatch.caches = cache.caches;\n\n/**\n * Expose `micromatch`\n * @type {Function}\n */\n\nmodule.exports = micromatch;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}