{"ast":null,"code":"'use strict';\n\nvar Base = require('base');\nvar define = require('define-property');\nvar Compiler = require('./lib/compiler');\nvar Parser = require('./lib/parser');\nvar utils = require('./lib/utils');\nvar regexCache = {};\nvar cache = {};\n\n/**\n * Create a new instance of `Snapdragon` with the given `options`.\n *\n * ```js\n * var snapdragon = new Snapdragon();\n * ```\n *\n * @param {Object} `options`\n * @api public\n */\n\nfunction Snapdragon(options) {\n  Base.call(this, null, options);\n  this.options = utils.extend({\n    source: 'string'\n  }, this.options);\n  this.compiler = new Compiler(this.options);\n  this.parser = new Parser(this.options);\n  Object.defineProperty(this, 'compilers', {\n    get: function () {\n      return this.compiler.compilers;\n    }\n  });\n  Object.defineProperty(this, 'parsers', {\n    get: function () {\n      return this.parser.parsers;\n    }\n  });\n  Object.defineProperty(this, 'regex', {\n    get: function () {\n      return this.parser.regex;\n    }\n  });\n}\n\n/**\n * Inherit Base\n */\n\nBase.extend(Snapdragon);\n\n/**\n * Add a parser to `snapdragon.parsers` for capturing the given `type` using\n * the specified regex or parser function. A function is useful if you need\n * to customize how the token is created and/or have access to the parser\n * instance to check options, etc.\n *\n * ```js\n * snapdragon\n *   .capture('slash', /^\\//)\n *   .capture('dot', function() {\n *     var pos = this.position();\n *     var m = this.match(/^\\./);\n *     if (!m) return;\n *     return pos({\n *       type: 'dot',\n *       val: m[0]\n *     });\n *   });\n * ```\n * @param {String} `type`\n * @param {RegExp|Function} `regex`\n * @return {Object} Returns the parser instance for chaining\n * @api public\n */\n\nSnapdragon.prototype.capture = function () {\n  return this.parser.capture.apply(this.parser, arguments);\n};\n\n/**\n * Register a plugin `fn`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * snapdragon.use(function() {\n *   console.log(this);          //<= snapdragon instance\n *   console.log(this.parser);   //<= parser instance\n *   console.log(this.compiler); //<= compiler instance\n * });\n * ```\n * @param {Object} `fn`\n * @api public\n */\n\nSnapdragon.prototype.use = function (fn) {\n  fn.call(this, this);\n  return this;\n};\n\n/**\n * Parse the given `str`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * // register parsers\n * snapdragon.parser.use(function() {});\n *\n * // parse\n * var ast = snapdragon.parse('foo/bar');\n * console.log(ast);\n * ```\n * @param {String} `str`\n * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.\n * @return {Object} Returns an AST.\n * @api public\n */\n\nSnapdragon.prototype.parse = function (str, options) {\n  this.options = utils.extend({}, this.options, options);\n  var parsed = this.parser.parse(str, this.options);\n\n  // add non-enumerable parser reference\n  define(parsed, 'parser', this.parser);\n  return parsed;\n};\n\n/**\n * Compile the given `AST`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * // register plugins\n * snapdragon.use(function() {});\n * // register parser plugins\n * snapdragon.parser.use(function() {});\n * // register compiler plugins\n * snapdragon.compiler.use(function() {});\n *\n * // parse\n * var ast = snapdragon.parse('foo/bar');\n *\n * // compile\n * var res = snapdragon.compile(ast);\n * console.log(res.output);\n * ```\n * @param {Object} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object with an `output` property with the rendered string.\n * @api public\n */\n\nSnapdragon.prototype.compile = function (ast, options) {\n  this.options = utils.extend({}, this.options, options);\n  var compiled = this.compiler.compile(ast, this.options);\n\n  // add non-enumerable compiler reference\n  define(compiled, 'compiler', this.compiler);\n  return compiled;\n};\n\n/**\n * Expose `Snapdragon`\n */\n\nmodule.exports = Snapdragon;\n\n/**\n * Expose `Parser` and `Compiler`\n */\n\nmodule.exports.Compiler = Compiler;\nmodule.exports.Parser = Parser;","map":{"version":3,"names":["Base","require","define","Compiler","Parser","utils","regexCache","cache","Snapdragon","options","call","extend","source","compiler","parser","Object","defineProperty","get","compilers","parsers","regex","prototype","capture","apply","arguments","use","fn","parse","str","parsed","compile","ast","compiled","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/snapdragon/index.js"],"sourcesContent":["'use strict';\n\nvar Base = require('base');\nvar define = require('define-property');\nvar Compiler = require('./lib/compiler');\nvar Parser = require('./lib/parser');\nvar utils = require('./lib/utils');\nvar regexCache = {};\nvar cache = {};\n\n/**\n * Create a new instance of `Snapdragon` with the given `options`.\n *\n * ```js\n * var snapdragon = new Snapdragon();\n * ```\n *\n * @param {Object} `options`\n * @api public\n */\n\nfunction Snapdragon(options) {\n  Base.call(this, null, options);\n  this.options = utils.extend({source: 'string'}, this.options);\n  this.compiler = new Compiler(this.options);\n  this.parser = new Parser(this.options);\n\n  Object.defineProperty(this, 'compilers', {\n    get: function() {\n      return this.compiler.compilers;\n    }\n  });\n\n  Object.defineProperty(this, 'parsers', {\n    get: function() {\n      return this.parser.parsers;\n    }\n  });\n\n  Object.defineProperty(this, 'regex', {\n    get: function() {\n      return this.parser.regex;\n    }\n  });\n}\n\n/**\n * Inherit Base\n */\n\nBase.extend(Snapdragon);\n\n/**\n * Add a parser to `snapdragon.parsers` for capturing the given `type` using\n * the specified regex or parser function. A function is useful if you need\n * to customize how the token is created and/or have access to the parser\n * instance to check options, etc.\n *\n * ```js\n * snapdragon\n *   .capture('slash', /^\\//)\n *   .capture('dot', function() {\n *     var pos = this.position();\n *     var m = this.match(/^\\./);\n *     if (!m) return;\n *     return pos({\n *       type: 'dot',\n *       val: m[0]\n *     });\n *   });\n * ```\n * @param {String} `type`\n * @param {RegExp|Function} `regex`\n * @return {Object} Returns the parser instance for chaining\n * @api public\n */\n\nSnapdragon.prototype.capture = function() {\n  return this.parser.capture.apply(this.parser, arguments);\n};\n\n/**\n * Register a plugin `fn`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * snapdragon.use(function() {\n *   console.log(this);          //<= snapdragon instance\n *   console.log(this.parser);   //<= parser instance\n *   console.log(this.compiler); //<= compiler instance\n * });\n * ```\n * @param {Object} `fn`\n * @api public\n */\n\nSnapdragon.prototype.use = function(fn) {\n  fn.call(this, this);\n  return this;\n};\n\n/**\n * Parse the given `str`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * // register parsers\n * snapdragon.parser.use(function() {});\n *\n * // parse\n * var ast = snapdragon.parse('foo/bar');\n * console.log(ast);\n * ```\n * @param {String} `str`\n * @param {Object} `options` Set `options.sourcemap` to true to enable source maps.\n * @return {Object} Returns an AST.\n * @api public\n */\n\nSnapdragon.prototype.parse = function(str, options) {\n  this.options = utils.extend({}, this.options, options);\n  var parsed = this.parser.parse(str, this.options);\n\n  // add non-enumerable parser reference\n  define(parsed, 'parser', this.parser);\n  return parsed;\n};\n\n/**\n * Compile the given `AST`.\n *\n * ```js\n * var snapdragon = new Snapdgragon([options]);\n * // register plugins\n * snapdragon.use(function() {});\n * // register parser plugins\n * snapdragon.parser.use(function() {});\n * // register compiler plugins\n * snapdragon.compiler.use(function() {});\n *\n * // parse\n * var ast = snapdragon.parse('foo/bar');\n *\n * // compile\n * var res = snapdragon.compile(ast);\n * console.log(res.output);\n * ```\n * @param {Object} `ast`\n * @param {Object} `options`\n * @return {Object} Returns an object with an `output` property with the rendered string.\n * @api public\n */\n\nSnapdragon.prototype.compile = function(ast, options) {\n  this.options = utils.extend({}, this.options, options);\n  var compiled = this.compiler.compile(ast, this.options);\n\n  // add non-enumerable compiler reference\n  define(compiled, 'compiler', this.compiler);\n  return compiled;\n};\n\n/**\n * Expose `Snapdragon`\n */\n\nmodule.exports = Snapdragon;\n\n/**\n * Expose `Parser` and `Compiler`\n */\n\nmodule.exports.Compiler = Compiler;\nmodule.exports.Parser = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}