{"ast":null,"code":"(function () {\n  'use strict';\n\n  /**\n   * Extend an Object with another Object's properties.\n   *\n   * The source objects are specified as additional arguments.\n   *\n   * @param dst Object the object to extend.\n   *\n   * @return Object the final object.\n   */\n  var _extend = function (dst) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    for (var i = 0; i < sources.length; ++i) {\n      var src = sources[i];\n      for (var p in src) {\n        if (src.hasOwnProperty(p)) dst[p] = src[p];\n      }\n    }\n    return dst;\n  };\n\n  /**\n   * Defer execution of given function.\n   * @param  {Function} func\n   */\n  var _defer = function (func) {\n    if (typeof setImmediate === 'function') {\n      return setImmediate(func);\n    } else {\n      return setTimeout(func, 0);\n    }\n  };\n\n  /**\n   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\n   */\n  var Levenshtein = {\n    /**\n     * Calculate levenshtein distance of the two strings.\n     *\n     * @param str1 String the first string.\n     * @param str2 String the second string.\n     * @return Integer the levenshtein distance (0 and above).\n     */\n    get: function (str1, str2) {\n      // base cases\n      if (str1 === str2) return 0;\n      if (str1.length === 0) return str2.length;\n      if (str2.length === 0) return str1.length;\n\n      // two rows\n      var prevRow = new Array(str2.length + 1),\n        curCol,\n        nextCol,\n        i,\n        j,\n        tmp;\n\n      // initialise previous row\n      for (i = 0; i < prevRow.length; ++i) {\n        prevRow[i] = i;\n      }\n\n      // calculate current row distance from previous row\n      for (i = 0; i < str1.length; ++i) {\n        nextCol = i + 1;\n        for (j = 0; j < str2.length; ++j) {\n          curCol = nextCol;\n\n          // substution\n          nextCol = prevRow[j] + (str1.charAt(i) === str2.charAt(j) ? 0 : 1);\n          // insertion\n          tmp = curCol + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n          // deletion\n          tmp = prevRow[j + 1] + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n\n          // copy current col value into previous (in preparation for next iteration)\n          prevRow[j] = curCol;\n        }\n\n        // copy last col value into previous (in preparation for next iteration)\n        prevRow[j] = nextCol;\n      }\n      return nextCol;\n    },\n    /**\n     * Asynchronously calculate levenshtein distance of the two strings.\n     *\n     * @param str1 String the first string.\n     * @param str2 String the second string.\n     * @param cb Function callback function with signature: function(Error err, int distance)\n     * @param [options] Object additional options.\n     * @param [options.progress] Function progress callback with signature: function(percentComplete)\n     */\n    getAsync: function (str1, str2, cb, options) {\n      options = _extend({}, {\n        progress: null\n      }, options);\n\n      // base cases\n      if (str1 === str2) return cb(null, 0);\n      if (str1.length === 0) return cb(null, str2.length);\n      if (str2.length === 0) return cb(null, str1.length);\n\n      // two rows\n      var prevRow = new Array(str2.length + 1),\n        curCol,\n        nextCol,\n        i,\n        j,\n        tmp,\n        startTime,\n        currentTime;\n\n      // initialise previous row\n      for (i = 0; i < prevRow.length; ++i) {\n        prevRow[i] = i;\n      }\n      nextCol = 1;\n      i = 0;\n      j = -1;\n      var __calculate = function () {\n        // reset timer\n        startTime = new Date().valueOf();\n        currentTime = startTime;\n\n        // keep going until one second has elapsed\n        while (currentTime - startTime < 1000) {\n          // reached end of current row?\n          if (str2.length <= ++j) {\n            // copy current into previous (in preparation for next iteration)\n            prevRow[j] = nextCol;\n\n            // if already done all chars\n            if (str1.length <= ++i) {\n              return cb(null, nextCol);\n            }\n            // else if we have more left to do\n            else {\n              nextCol = i + 1;\n              j = 0;\n            }\n          }\n\n          // calculation\n          curCol = nextCol;\n\n          // substution\n          nextCol = prevRow[j] + (str1.charAt(i) === str2.charAt(j) ? 0 : 1);\n          // insertion\n          tmp = curCol + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n          // deletion\n          tmp = prevRow[j + 1] + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n\n          // copy current into previous (in preparation for next iteration)\n          prevRow[j] = curCol;\n\n          // get current time\n          currentTime = new Date().valueOf();\n        }\n\n        // send a progress update?\n        if (null !== options.progress) {\n          try {\n            options.progress.call(null, i * 100.0 / str1.length);\n          } catch (err) {\n            return cb('Progress callback: ' + err.toString());\n          }\n        }\n\n        // next iteration\n        _defer(__calculate);\n      };\n      __calculate();\n    }\n  };\n\n  // amd\n  if (typeof define !== \"undefined\" && define !== null && define.amd) {\n    define(function () {\n      return Levenshtein;\n    });\n  }\n  // commonjs\n  else if (typeof module !== \"undefined\" && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\n    module.exports = Levenshtein;\n  }\n  // web worker\n  else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\n    self.Levenshtein = Levenshtein;\n  }\n  // browser main thread\n  else if (typeof window !== \"undefined\" && window !== null) {\n    window.Levenshtein = Levenshtein;\n  }\n})();","map":{"version":3,"names":["_extend","dst","sources","Array","prototype","slice","call","arguments","i","length","src","p","hasOwnProperty","_defer","func","setImmediate","setTimeout","Levenshtein","get","str1","str2","prevRow","curCol","nextCol","j","tmp","charAt","getAsync","cb","options","progress","startTime","currentTime","__calculate","Date","valueOf","err","toString","define","amd","module","exports","self","postMessage","importScripts","window"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/undertaker/node_modules/fast-levenshtein/levenshtein.js"],"sourcesContent":["(function() {\n  'use strict';\n\n  /**\n   * Extend an Object with another Object's properties.\n   *\n   * The source objects are specified as additional arguments.\n   *\n   * @param dst Object the object to extend.\n   *\n   * @return Object the final object.\n   */\n  var _extend = function(dst) {\n    var sources = Array.prototype.slice.call(arguments, 1);\n    for (var i=0; i<sources.length; ++i) {\n      var src = sources[i];\n      for (var p in src) {\n        if (src.hasOwnProperty(p)) dst[p] = src[p];\n      }\n    }\n    return dst;\n  };\n\n\n  /**\n   * Defer execution of given function.\n   * @param  {Function} func\n   */\n  var _defer = function(func) {\n    if (typeof setImmediate === 'function') {\n      return setImmediate(func);\n    } else {\n      return setTimeout(func, 0);\n    }\n  };\n\n  /**\n   * Based on the algorithm at http://en.wikipedia.org/wiki/Levenshtein_distance.\n   */\n  var Levenshtein = {\n    /**\n     * Calculate levenshtein distance of the two strings.\n     *\n     * @param str1 String the first string.\n     * @param str2 String the second string.\n     * @return Integer the levenshtein distance (0 and above).\n     */\n    get: function(str1, str2) {\n      // base cases\n      if (str1 === str2) return 0;\n      if (str1.length === 0) return str2.length;\n      if (str2.length === 0) return str1.length;\n\n      // two rows\n      var prevRow  = new Array(str2.length + 1),\n          curCol, nextCol, i, j, tmp;\n\n      // initialise previous row\n      for (i=0; i<prevRow.length; ++i) {\n        prevRow[i] = i;\n      }\n\n      // calculate current row distance from previous row\n      for (i=0; i<str1.length; ++i) {\n        nextCol = i + 1;\n\n        for (j=0; j<str2.length; ++j) {\n          curCol = nextCol;\n\n          // substution\n          nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );\n          // insertion\n          tmp = curCol + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n          // deletion\n          tmp = prevRow[j + 1] + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n\n          // copy current col value into previous (in preparation for next iteration)\n          prevRow[j] = curCol;\n        }\n\n        // copy last col value into previous (in preparation for next iteration)\n        prevRow[j] = nextCol;\n      }\n\n      return nextCol;\n    },\n\n    /**\n     * Asynchronously calculate levenshtein distance of the two strings.\n     *\n     * @param str1 String the first string.\n     * @param str2 String the second string.\n     * @param cb Function callback function with signature: function(Error err, int distance)\n     * @param [options] Object additional options.\n     * @param [options.progress] Function progress callback with signature: function(percentComplete)\n     */\n    getAsync: function(str1, str2, cb, options) {\n      options = _extend({}, {\n        progress: null\n      }, options);\n\n      // base cases\n      if (str1 === str2) return cb(null, 0);\n      if (str1.length === 0) return cb(null, str2.length);\n      if (str2.length === 0) return cb(null, str1.length);\n\n      // two rows\n      var prevRow  = new Array(str2.length + 1),\n          curCol, nextCol,\n          i, j, tmp,\n          startTime, currentTime;\n\n      // initialise previous row\n      for (i=0; i<prevRow.length; ++i) {\n        prevRow[i] = i;\n      }\n\n      nextCol = 1;\n      i = 0;\n      j = -1;\n\n      var __calculate = function() {\n        // reset timer\n        startTime = new Date().valueOf();\n        currentTime = startTime;\n\n        // keep going until one second has elapsed\n        while (currentTime - startTime < 1000) {\n          // reached end of current row?\n          if (str2.length <= (++j)) {\n            // copy current into previous (in preparation for next iteration)\n            prevRow[j] = nextCol;\n\n            // if already done all chars\n            if (str1.length <= (++i)) {\n              return cb(null, nextCol);\n            }\n            // else if we have more left to do\n            else {\n              nextCol = i + 1;\n              j = 0;\n            }\n          }\n\n          // calculation\n          curCol = nextCol;\n\n          // substution\n          nextCol = prevRow[j] + ( (str1.charAt(i) === str2.charAt(j)) ? 0 : 1 );\n          // insertion\n          tmp = curCol + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n          // deletion\n          tmp = prevRow[j + 1] + 1;\n          if (nextCol > tmp) {\n            nextCol = tmp;\n          }\n\n          // copy current into previous (in preparation for next iteration)\n          prevRow[j] = curCol;\n\n          // get current time\n          currentTime = new Date().valueOf();\n        }\n\n        // send a progress update?\n        if (null !== options.progress) {\n          try {\n            options.progress.call(null, (i * 100.0/ str1.length));\n          } catch (err) {\n            return cb('Progress callback: ' + err.toString());\n          }\n        }\n\n        // next iteration\n        _defer(__calculate);\n      };\n\n      __calculate();\n    }\n\n  };\n\n  // amd\n  if (typeof define !== \"undefined\" && define !== null && define.amd) {\n    define(function() {\n      return Levenshtein;\n    });\n  }\n  // commonjs\n  else if (typeof module !== \"undefined\" && module !== null && typeof exports !== \"undefined\" && module.exports === exports) {\n    module.exports = Levenshtein;\n  }\n  // web worker\n  else if (typeof self !== \"undefined\" && typeof self.postMessage === 'function' && typeof self.importScripts === 'function') {\n    self.Levenshtein = Levenshtein;\n  }\n  // browser main thread\n  else if (typeof window !== \"undefined\" && window !== null) {\n    window.Levenshtein = Levenshtein;\n  }\n}());\n\n"],"mappings":"AAAC,aAAW;EACV,YAAY;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIA,OAAO,GAAG,UAASC,GAAG,EAAE;IAC1B,IAAIC,OAAO,GAAGC,KAAK,CAACC,SAAS,CAACC,KAAK,CAACC,IAAI,CAACC,SAAS,EAAE,CAAC,CAAC;IACtD,KAAK,IAAIC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACN,OAAO,CAACO,MAAM,EAAE,EAAED,CAAC,EAAE;MACnC,IAAIE,GAAG,GAAGR,OAAO,CAACM,CAAC,CAAC;MACpB,KAAK,IAAIG,CAAC,IAAID,GAAG,EAAE;QACjB,IAAIA,GAAG,CAACE,cAAc,CAACD,CAAC,CAAC,EAAEV,GAAG,CAACU,CAAC,CAAC,GAAGD,GAAG,CAACC,CAAC,CAAC;MAC5C;IACF;IACA,OAAOV,GAAG;EACZ,CAAC;;EAGD;AACF;AACA;AACA;EACE,IAAIY,MAAM,GAAG,UAASC,IAAI,EAAE;IAC1B,IAAI,OAAOC,YAAY,KAAK,UAAU,EAAE;MACtC,OAAOA,YAAY,CAACD,IAAI,CAAC;IAC3B,CAAC,MAAM;MACL,OAAOE,UAAU,CAACF,IAAI,EAAE,CAAC,CAAC;IAC5B;EACF,CAAC;;EAED;AACF;AACA;EACE,IAAIG,WAAW,GAAG;IAChB;AACJ;AACA;AACA;AACA;AACA;AACA;IACIC,GAAG,EAAE,UAASC,IAAI,EAAEC,IAAI,EAAE;MACxB;MACA,IAAID,IAAI,KAAKC,IAAI,EAAE,OAAO,CAAC;MAC3B,IAAID,IAAI,CAACV,MAAM,KAAK,CAAC,EAAE,OAAOW,IAAI,CAACX,MAAM;MACzC,IAAIW,IAAI,CAACX,MAAM,KAAK,CAAC,EAAE,OAAOU,IAAI,CAACV,MAAM;;MAEzC;MACA,IAAIY,OAAO,GAAI,IAAIlB,KAAK,CAACiB,IAAI,CAACX,MAAM,GAAG,CAAC,CAAC;QACrCa,MAAM;QAAEC,OAAO;QAAEf,CAAC;QAAEgB,CAAC;QAAEC,GAAG;;MAE9B;MACA,KAAKjB,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACa,OAAO,CAACZ,MAAM,EAAE,EAAED,CAAC,EAAE;QAC/Ba,OAAO,CAACb,CAAC,CAAC,GAAGA,CAAC;MAChB;;MAEA;MACA,KAAKA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACW,IAAI,CAACV,MAAM,EAAE,EAAED,CAAC,EAAE;QAC5Be,OAAO,GAAGf,CAAC,GAAG,CAAC;QAEf,KAAKgB,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACJ,IAAI,CAACX,MAAM,EAAE,EAAEe,CAAC,EAAE;UAC5BF,MAAM,GAAGC,OAAO;;UAEhB;UACAA,OAAO,GAAGF,OAAO,CAACG,CAAC,CAAC,IAAML,IAAI,CAACO,MAAM,CAAClB,CAAC,CAAC,KAAKY,IAAI,CAACM,MAAM,CAACF,CAAC,CAAC,GAAI,CAAC,GAAG,CAAC,CAAE;UACtE;UACAC,GAAG,GAAGH,MAAM,GAAG,CAAC;UAChB,IAAIC,OAAO,GAAGE,GAAG,EAAE;YACjBF,OAAO,GAAGE,GAAG;UACf;UACA;UACAA,GAAG,GAAGJ,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UACxB,IAAID,OAAO,GAAGE,GAAG,EAAE;YACjBF,OAAO,GAAGE,GAAG;UACf;;UAEA;UACAJ,OAAO,CAACG,CAAC,CAAC,GAAGF,MAAM;QACrB;;QAEA;QACAD,OAAO,CAACG,CAAC,CAAC,GAAGD,OAAO;MACtB;MAEA,OAAOA,OAAO;IAChB,CAAC;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACII,QAAQ,EAAE,UAASR,IAAI,EAAEC,IAAI,EAAEQ,EAAE,EAAEC,OAAO,EAAE;MAC1CA,OAAO,GAAG7B,OAAO,CAAC,CAAC,CAAC,EAAE;QACpB8B,QAAQ,EAAE;MACZ,CAAC,EAAED,OAAO,CAAC;;MAEX;MACA,IAAIV,IAAI,KAAKC,IAAI,EAAE,OAAOQ,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;MACrC,IAAIT,IAAI,CAACV,MAAM,KAAK,CAAC,EAAE,OAAOmB,EAAE,CAAC,IAAI,EAAER,IAAI,CAACX,MAAM,CAAC;MACnD,IAAIW,IAAI,CAACX,MAAM,KAAK,CAAC,EAAE,OAAOmB,EAAE,CAAC,IAAI,EAAET,IAAI,CAACV,MAAM,CAAC;;MAEnD;MACA,IAAIY,OAAO,GAAI,IAAIlB,KAAK,CAACiB,IAAI,CAACX,MAAM,GAAG,CAAC,CAAC;QACrCa,MAAM;QAAEC,OAAO;QACff,CAAC;QAAEgB,CAAC;QAAEC,GAAG;QACTM,SAAS;QAAEC,WAAW;;MAE1B;MACA,KAAKxB,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACa,OAAO,CAACZ,MAAM,EAAE,EAAED,CAAC,EAAE;QAC/Ba,OAAO,CAACb,CAAC,CAAC,GAAGA,CAAC;MAChB;MAEAe,OAAO,GAAG,CAAC;MACXf,CAAC,GAAG,CAAC;MACLgB,CAAC,GAAG,CAAC,CAAC;MAEN,IAAIS,WAAW,GAAG,YAAW;QAC3B;QACAF,SAAS,GAAG,IAAIG,IAAI,EAAE,CAACC,OAAO,EAAE;QAChCH,WAAW,GAAGD,SAAS;;QAEvB;QACA,OAAOC,WAAW,GAAGD,SAAS,GAAG,IAAI,EAAE;UACrC;UACA,IAAIX,IAAI,CAACX,MAAM,IAAK,EAAEe,CAAE,EAAE;YACxB;YACAH,OAAO,CAACG,CAAC,CAAC,GAAGD,OAAO;;YAEpB;YACA,IAAIJ,IAAI,CAACV,MAAM,IAAK,EAAED,CAAE,EAAE;cACxB,OAAOoB,EAAE,CAAC,IAAI,EAAEL,OAAO,CAAC;YAC1B;YACA;YAAA,KACK;cACHA,OAAO,GAAGf,CAAC,GAAG,CAAC;cACfgB,CAAC,GAAG,CAAC;YACP;UACF;;UAEA;UACAF,MAAM,GAAGC,OAAO;;UAEhB;UACAA,OAAO,GAAGF,OAAO,CAACG,CAAC,CAAC,IAAML,IAAI,CAACO,MAAM,CAAClB,CAAC,CAAC,KAAKY,IAAI,CAACM,MAAM,CAACF,CAAC,CAAC,GAAI,CAAC,GAAG,CAAC,CAAE;UACtE;UACAC,GAAG,GAAGH,MAAM,GAAG,CAAC;UAChB,IAAIC,OAAO,GAAGE,GAAG,EAAE;YACjBF,OAAO,GAAGE,GAAG;UACf;UACA;UACAA,GAAG,GAAGJ,OAAO,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;UACxB,IAAID,OAAO,GAAGE,GAAG,EAAE;YACjBF,OAAO,GAAGE,GAAG;UACf;;UAEA;UACAJ,OAAO,CAACG,CAAC,CAAC,GAAGF,MAAM;;UAEnB;UACAU,WAAW,GAAG,IAAIE,IAAI,EAAE,CAACC,OAAO,EAAE;QACpC;;QAEA;QACA,IAAI,IAAI,KAAKN,OAAO,CAACC,QAAQ,EAAE;UAC7B,IAAI;YACFD,OAAO,CAACC,QAAQ,CAACxB,IAAI,CAAC,IAAI,EAAGE,CAAC,GAAG,KAAK,GAAEW,IAAI,CAACV,MAAM,CAAE;UACvD,CAAC,CAAC,OAAO2B,GAAG,EAAE;YACZ,OAAOR,EAAE,CAAC,qBAAqB,GAAGQ,GAAG,CAACC,QAAQ,EAAE,CAAC;UACnD;QACF;;QAEA;QACAxB,MAAM,CAACoB,WAAW,CAAC;MACrB,CAAC;MAEDA,WAAW,EAAE;IACf;EAEF,CAAC;;EAED;EACA,IAAI,OAAOK,MAAM,KAAK,WAAW,IAAIA,MAAM,KAAK,IAAI,IAAIA,MAAM,CAACC,GAAG,EAAE;IAClED,MAAM,CAAC,YAAW;MAChB,OAAOrB,WAAW;IACpB,CAAC,CAAC;EACJ;EACA;EAAA,KACK,IAAI,OAAOuB,MAAM,KAAK,WAAW,IAAIA,MAAM,KAAK,IAAI,IAAI,OAAOC,OAAO,KAAK,WAAW,IAAID,MAAM,CAACC,OAAO,KAAKA,OAAO,EAAE;IACzHD,MAAM,CAACC,OAAO,GAAGxB,WAAW;EAC9B;EACA;EAAA,KACK,IAAI,OAAOyB,IAAI,KAAK,WAAW,IAAI,OAAOA,IAAI,CAACC,WAAW,KAAK,UAAU,IAAI,OAAOD,IAAI,CAACE,aAAa,KAAK,UAAU,EAAE;IAC1HF,IAAI,CAACzB,WAAW,GAAGA,WAAW;EAChC;EACA;EAAA,KACK,IAAI,OAAO4B,MAAM,KAAK,WAAW,IAAIA,MAAM,KAAK,IAAI,EAAE;IACzDA,MAAM,CAAC5B,WAAW,GAAGA,WAAW;EAClC;AACF,CAAC,GAAE"},"metadata":{},"sourceType":"script"}