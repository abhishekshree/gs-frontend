{"ast":null,"code":"'use strict';\n\nvar safe = require('safe-regex');\nvar define = require('define-property');\nvar extend = require('extend-shallow');\nvar not = require('regex-not');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * Session cache\n */\n\nvar cache = {};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nmodule.exports = function (patterns, options) {\n  if (!Array.isArray(patterns)) {\n    return makeRe(patterns, options);\n  }\n  return makeRe(patterns.join('|'), options);\n};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nfunction makeRe(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n  var key = pattern;\n  // do this before shallow cloning options, it's a lot faster\n  if (!options || options && options.cache !== false) {\n    key = createKey(pattern, options);\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n  }\n  var opts = extend({}, options);\n  if (opts.contains === true) {\n    if (opts.negate === true) {\n      opts.strictNegate = false;\n    } else {\n      opts.strict = false;\n    }\n  }\n  if (opts.strict === false) {\n    opts.strictOpen = false;\n    opts.strictClose = false;\n  }\n  var open = opts.strictOpen !== false ? '^' : '';\n  var close = opts.strictClose !== false ? '$' : '';\n  var flags = opts.flags || '';\n  var regex;\n  if (opts.nocase === true && !/i/.test(flags)) {\n    flags += 'i';\n  }\n  try {\n    if (opts.negate || typeof opts.strictNegate === 'boolean') {\n      pattern = not.create(pattern, opts);\n    }\n    var str = open + '(?:' + pattern + ')' + close;\n    regex = new RegExp(str, flags);\n    if (opts.safe === true && safe(regex) === false) {\n      throw new Error('potentially unsafe regular expression: ' + regex.source);\n    }\n  } catch (err) {\n    if (opts.strictErrors === true || opts.safe === true) {\n      err.key = key;\n      err.pattern = pattern;\n      err.originalOptions = options;\n      err.createdOptions = opts;\n      throw err;\n    }\n    try {\n      regex = new RegExp('^' + pattern.replace(/(\\W)/g, '\\\\$1') + '$');\n    } catch (err) {\n      regex = /.^/; //<= match nothing\n    }\n  }\n\n  if (opts.cache !== false) {\n    memoize(regex, key, pattern, opts);\n  }\n  return regex;\n}\n\n/**\n * Memoize generated regex. This can result in dramatic speed improvements\n * and simplify debugging by adding options and pattern to the regex. It can be\n * disabled by passing setting `options.cache` to false.\n */\n\nfunction memoize(regex, key, pattern, options) {\n  define(regex, 'cached', true);\n  define(regex, 'pattern', pattern);\n  define(regex, 'options', options);\n  define(regex, 'key', key);\n  cache[key] = regex;\n}\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nfunction createKey(pattern, options) {\n  if (!options) return pattern;\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n  return key;\n}\n\n/**\n * Expose `makeRe`\n */\n\nmodule.exports.makeRe = makeRe;","map":{"version":3,"names":["safe","require","define","extend","not","MAX_LENGTH","cache","module","exports","patterns","options","Array","isArray","makeRe","join","pattern","RegExp","TypeError","length","Error","key","createKey","hasOwnProperty","opts","contains","negate","strictNegate","strict","strictOpen","strictClose","open","close","flags","regex","nocase","test","create","str","source","err","strictErrors","originalOptions","createdOptions","replace","memoize","prop","String"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/to-regex/index.js"],"sourcesContent":["'use strict';\n\nvar safe = require('safe-regex');\nvar define = require('define-property');\nvar extend = require('extend-shallow');\nvar not = require('regex-not');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * Session cache\n */\n\nvar cache = {};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nmodule.exports = function(patterns, options) {\n  if (!Array.isArray(patterns)) {\n    return makeRe(patterns, options);\n  }\n  return makeRe(patterns.join('|'), options);\n};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nfunction makeRe(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  var key = pattern;\n  // do this before shallow cloning options, it's a lot faster\n  if (!options || (options && options.cache !== false)) {\n    key = createKey(pattern, options);\n\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n  }\n\n  var opts = extend({}, options);\n  if (opts.contains === true) {\n    if (opts.negate === true) {\n      opts.strictNegate = false;\n    } else {\n      opts.strict = false;\n    }\n  }\n\n  if (opts.strict === false) {\n    opts.strictOpen = false;\n    opts.strictClose = false;\n  }\n\n  var open = opts.strictOpen !== false ? '^' : '';\n  var close = opts.strictClose !== false ? '$' : '';\n  var flags = opts.flags || '';\n  var regex;\n\n  if (opts.nocase === true && !/i/.test(flags)) {\n    flags += 'i';\n  }\n\n  try {\n    if (opts.negate || typeof opts.strictNegate === 'boolean') {\n      pattern = not.create(pattern, opts);\n    }\n\n    var str = open + '(?:' + pattern + ')' + close;\n    regex = new RegExp(str, flags);\n\n    if (opts.safe === true && safe(regex) === false) {\n      throw new Error('potentially unsafe regular expression: ' + regex.source);\n    }\n\n  } catch (err) {\n    if (opts.strictErrors === true || opts.safe === true) {\n      err.key = key;\n      err.pattern = pattern;\n      err.originalOptions = options;\n      err.createdOptions = opts;\n      throw err;\n    }\n\n    try {\n      regex = new RegExp('^' + pattern.replace(/(\\W)/g, '\\\\$1') + '$');\n    } catch (err) {\n      regex = /.^/; //<= match nothing\n    }\n  }\n\n  if (opts.cache !== false) {\n    memoize(regex, key, pattern, opts);\n  }\n  return regex;\n}\n\n/**\n * Memoize generated regex. This can result in dramatic speed improvements\n * and simplify debugging by adding options and pattern to the regex. It can be\n * disabled by passing setting `options.cache` to false.\n */\n\nfunction memoize(regex, key, pattern, options) {\n  define(regex, 'cached', true);\n  define(regex, 'pattern', pattern);\n  define(regex, 'options', options);\n  define(regex, 'key', key);\n  cache[key] = regex;\n}\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nfunction createKey(pattern, options) {\n  if (!options) return pattern;\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n  return key;\n}\n\n/**\n * Expose `makeRe`\n */\n\nmodule.exports.makeRe = makeRe;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}