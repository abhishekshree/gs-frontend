{"ast":null,"code":"'use strict';\n\nvar util = require('util');\nvar fs = require('graceful-fs');\nvar assign = require('object.assign');\nvar date = require('value-or-function').date;\nvar Writable = require('readable-stream').Writable;\nvar constants = require('./constants');\nvar APPEND_MODE_REGEXP = /a/;\nfunction closeFd(propagatedErr, fd, callback) {\n  if (typeof fd !== 'number') {\n    return callback(propagatedErr);\n  }\n  fs.close(fd, onClosed);\n  function onClosed(closeErr) {\n    if (propagatedErr || closeErr) {\n      return callback(propagatedErr || closeErr);\n    }\n    callback();\n  }\n}\nfunction isValidUnixId(id) {\n  if (typeof id !== 'number') {\n    return false;\n  }\n  if (id < 0) {\n    return false;\n  }\n  return true;\n}\nfunction getFlags(options) {\n  var flags = !options.append ? 'w' : 'a';\n  if (!options.overwrite) {\n    flags += 'x';\n  }\n  return flags;\n}\nfunction isFatalOverwriteError(err, flags) {\n  if (!err) {\n    return false;\n  }\n  if (err.code === 'EEXIST' && flags[1] === 'x') {\n    // Handle scenario for file overwrite failures.\n    return false;\n  }\n\n  // Otherwise, this is a fatal error\n  return true;\n}\nfunction isFatalUnlinkError(err) {\n  if (!err || err.code === 'ENOENT') {\n    return false;\n  }\n  return true;\n}\nfunction getModeDiff(fsMode, vinylMode) {\n  var modeDiff = 0;\n  if (typeof vinylMode === 'number') {\n    modeDiff = (vinylMode ^ fsMode) & constants.MASK_MODE;\n  }\n  return modeDiff;\n}\nfunction getTimesDiff(fsStat, vinylStat) {\n  var mtime = date(vinylStat.mtime) || 0;\n  if (!mtime) {\n    return;\n  }\n  var atime = date(vinylStat.atime) || 0;\n  if (+mtime === +fsStat.mtime && +atime === +fsStat.atime) {\n    return;\n  }\n  if (!atime) {\n    atime = date(fsStat.atime) || undefined;\n  }\n  var timesDiff = {\n    mtime: vinylStat.mtime,\n    atime: atime\n  };\n  return timesDiff;\n}\nfunction getOwnerDiff(fsStat, vinylStat) {\n  if (!isValidUnixId(vinylStat.uid) && !isValidUnixId(vinylStat.gid)) {\n    return;\n  }\n  if (!isValidUnixId(fsStat.uid) && !isValidUnixId(vinylStat.uid) || !isValidUnixId(fsStat.gid) && !isValidUnixId(vinylStat.gid)) {\n    return;\n  }\n  var uid = fsStat.uid; // Default to current uid.\n  if (isValidUnixId(vinylStat.uid)) {\n    uid = vinylStat.uid;\n  }\n  var gid = fsStat.gid; // Default to current gid.\n  if (isValidUnixId(vinylStat.gid)) {\n    gid = vinylStat.gid;\n  }\n  if (uid === fsStat.uid && gid === fsStat.gid) {\n    return;\n  }\n  var ownerDiff = {\n    uid: uid,\n    gid: gid\n  };\n  return ownerDiff;\n}\nfunction isOwner(fsStat) {\n  var hasGetuid = typeof process.getuid === 'function';\n  var hasGeteuid = typeof process.geteuid === 'function';\n\n  // If we don't have either, assume we don't have permissions.\n  // This should only happen on Windows.\n  // Windows basically noops fchmod and errors on futimes called on directories.\n  if (!hasGeteuid && !hasGetuid) {\n    return false;\n  }\n  var uid;\n  if (hasGeteuid) {\n    uid = process.geteuid();\n  } else {\n    uid = process.getuid();\n  }\n  if (fsStat.uid !== uid && uid !== 0) {\n    return false;\n  }\n  return true;\n}\nfunction reflectStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.stat(path, onStat);\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    }\n    file.stat = stat;\n    callback();\n  }\n}\nfunction reflectLinkStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.lstat(path, onLstat);\n  function onLstat(lstatErr, stat) {\n    if (lstatErr) {\n      return callback(lstatErr);\n    }\n    file.stat = stat;\n    callback();\n  }\n}\nfunction updateMetadata(fd, file, callback) {\n  fs.fstat(fd, onStat);\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    }\n\n    // Check if mode needs to be updated\n    var modeDiff = getModeDiff(stat.mode, file.stat.mode);\n\n    // Check if atime/mtime need to be updated\n    var timesDiff = getTimesDiff(stat, file.stat);\n\n    // Check if uid/gid need to be updated\n    var ownerDiff = getOwnerDiff(stat, file.stat);\n\n    // Set file.stat to the reflect current state on disk\n    assign(file.stat, stat);\n\n    // Nothing to do\n    if (!modeDiff && !timesDiff && !ownerDiff) {\n      return callback();\n    }\n\n    // Check access, `futimes`, `fchmod` & `fchown` only work if we own\n    // the file, or if we are effectively root (`fchown` only when root).\n    if (!isOwner(stat)) {\n      return callback();\n    }\n    if (modeDiff) {\n      return mode();\n    }\n    if (timesDiff) {\n      return times();\n    }\n    owner();\n    function mode() {\n      var mode = stat.mode ^ modeDiff;\n      fs.fchmod(fd, mode, onFchmod);\n      function onFchmod(fchmodErr) {\n        if (!fchmodErr) {\n          file.stat.mode = mode;\n        }\n        if (timesDiff) {\n          return times(fchmodErr);\n        }\n        if (ownerDiff) {\n          return owner(fchmodErr);\n        }\n        callback(fchmodErr);\n      }\n    }\n    function times(propagatedErr) {\n      fs.futimes(fd, timesDiff.atime, timesDiff.mtime, onFutimes);\n      function onFutimes(futimesErr) {\n        if (!futimesErr) {\n          file.stat.atime = timesDiff.atime;\n          file.stat.mtime = timesDiff.mtime;\n        }\n        if (ownerDiff) {\n          return owner(propagatedErr || futimesErr);\n        }\n        callback(propagatedErr || futimesErr);\n      }\n    }\n    function owner(propagatedErr) {\n      fs.fchown(fd, ownerDiff.uid, ownerDiff.gid, onFchown);\n      function onFchown(fchownErr) {\n        if (!fchownErr) {\n          file.stat.uid = ownerDiff.uid;\n          file.stat.gid = ownerDiff.gid;\n        }\n        callback(propagatedErr || fchownErr);\n      }\n    }\n  }\n}\nfunction symlink(srcPath, destPath, opts, callback) {\n  // Because fs.symlink does not allow atomic overwrite option with flags, we\n  // delete and recreate if the link already exists and overwrite is true.\n  if (opts.flags === 'w') {\n    // TODO What happens when we call unlink with windows junctions?\n    fs.unlink(destPath, onUnlink);\n  } else {\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n  function onUnlink(unlinkErr) {\n    if (isFatalUnlinkError(unlinkErr)) {\n      return callback(unlinkErr);\n    }\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n  function onSymlink(symlinkErr) {\n    if (isFatalOverwriteError(symlinkErr, opts.flags)) {\n      return callback(symlinkErr);\n    }\n    callback();\n  }\n}\n\n/*\n  Custom writeFile implementation because we need access to the\n  file descriptor after the write is complete.\n  Most of the implementation taken from node core.\n */\nfunction writeFile(filepath, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (!Buffer.isBuffer(data)) {\n    return callback(new TypeError('Data must be a Buffer'));\n  }\n  if (!options) {\n    options = {};\n  }\n\n  // Default the same as node\n  var mode = options.mode || constants.DEFAULT_FILE_MODE;\n  var flags = options.flags || 'w';\n  var position = APPEND_MODE_REGEXP.test(flags) ? null : 0;\n  fs.open(filepath, flags, mode, onOpen);\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      return onComplete(openErr);\n    }\n    fs.write(fd, data, 0, data.length, position, onComplete);\n    function onComplete(writeErr) {\n      callback(writeErr, fd);\n    }\n  }\n}\nfunction createWriteStream(path, options, flush) {\n  return new WriteStream(path, options, flush);\n}\n\n// Taken from node core and altered to receive a flush function and simplified\n// To be used for cleanup (like updating times/mode/etc)\nfunction WriteStream(path, options, flush) {\n  // Not exposed so we can avoid the case where someone doesn't use `new`\n\n  if (typeof options === 'function') {\n    flush = options;\n    options = null;\n  }\n  options = options || {};\n  Writable.call(this, options);\n  this.flush = flush;\n  this.path = path;\n  this.mode = options.mode || constants.DEFAULT_FILE_MODE;\n  this.flags = options.flags || 'w';\n\n  // Used by node's `fs.WriteStream`\n  this.fd = null;\n  this.start = null;\n  this.open();\n\n  // Dispose on finish.\n  this.once('finish', this.close);\n}\nutil.inherits(WriteStream, Writable);\nWriteStream.prototype.open = function () {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, onOpen);\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      self.destroy();\n      self.emit('error', openErr);\n      return;\n    }\n    self.fd = fd;\n    self.emit('open', fd);\n  }\n};\n\n// Use our `end` method since it is patched for flush\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\nWriteStream.prototype._destroy = function (err, cb) {\n  this.close(function (err2) {\n    cb(err || err2);\n  });\n};\nWriteStream.prototype.close = function (cb) {\n  var that = this;\n  if (cb) {\n    this.once('close', cb);\n  }\n  if (this.closed || typeof this.fd !== 'number') {\n    if (typeof this.fd !== 'number') {\n      this.once('open', closeOnOpen);\n      return;\n    }\n    return process.nextTick(function () {\n      that.emit('close');\n    });\n  }\n  this.closed = true;\n  fs.close(this.fd, function (er) {\n    if (er) {\n      that.emit('error', er);\n    } else {\n      that.emit('close');\n    }\n  });\n  this.fd = null;\n};\nWriteStream.prototype._final = function (callback) {\n  if (typeof this.flush !== 'function') {\n    return callback();\n  }\n  this.flush(this.fd, callback);\n};\nfunction closeOnOpen() {\n  this.close();\n}\nWriteStream.prototype._write = function (data, encoding, callback) {\n  var self = this;\n\n  // This is from node core but I have no idea how to get code coverage on it\n  if (!Buffer.isBuffer(data)) {\n    return this.emit('error', new Error('Invalid data'));\n  }\n  if (typeof this.fd !== 'number') {\n    return this.once('open', onOpen);\n  }\n  fs.write(this.fd, data, 0, data.length, null, onWrite);\n  function onOpen() {\n    self._write(data, encoding, callback);\n  }\n  function onWrite(writeErr) {\n    if (writeErr) {\n      self.destroy();\n      callback(writeErr);\n      return;\n    }\n    callback();\n  }\n};\nmodule.exports = {\n  closeFd: closeFd,\n  isValidUnixId: isValidUnixId,\n  getFlags: getFlags,\n  isFatalOverwriteError: isFatalOverwriteError,\n  isFatalUnlinkError: isFatalUnlinkError,\n  getModeDiff: getModeDiff,\n  getTimesDiff: getTimesDiff,\n  getOwnerDiff: getOwnerDiff,\n  isOwner: isOwner,\n  reflectStat: reflectStat,\n  reflectLinkStat: reflectLinkStat,\n  updateMetadata: updateMetadata,\n  symlink: symlink,\n  writeFile: writeFile,\n  createWriteStream: createWriteStream\n};","map":{"version":3,"names":["util","require","fs","assign","date","Writable","constants","APPEND_MODE_REGEXP","closeFd","propagatedErr","fd","callback","close","onClosed","closeErr","isValidUnixId","id","getFlags","options","flags","append","overwrite","isFatalOverwriteError","err","code","isFatalUnlinkError","getModeDiff","fsMode","vinylMode","modeDiff","MASK_MODE","getTimesDiff","fsStat","vinylStat","mtime","atime","undefined","timesDiff","getOwnerDiff","uid","gid","ownerDiff","isOwner","hasGetuid","process","getuid","hasGeteuid","geteuid","reflectStat","path","file","stat","onStat","statErr","reflectLinkStat","lstat","onLstat","lstatErr","updateMetadata","fstat","mode","times","owner","fchmod","onFchmod","fchmodErr","futimes","onFutimes","futimesErr","fchown","onFchown","fchownErr","symlink","srcPath","destPath","opts","unlink","onUnlink","type","onSymlink","unlinkErr","symlinkErr","writeFile","filepath","data","Buffer","isBuffer","TypeError","DEFAULT_FILE_MODE","position","test","open","onOpen","openErr","onComplete","write","length","writeErr","createWriteStream","flush","WriteStream","call","start","once","inherits","prototype","self","destroy","emit","destroySoon","end","_destroy","cb","err2","that","closed","closeOnOpen","nextTick","er","_final","_write","encoding","Error","onWrite","module","exports"],"sources":["/home/krishnansh/Documents/WebDev/PS/notus-react-main/node_modules/vinyl-fs/lib/file-operations.js"],"sourcesContent":["'use strict';\n\nvar util = require('util');\n\nvar fs = require('graceful-fs');\nvar assign = require('object.assign');\nvar date = require('value-or-function').date;\nvar Writable = require('readable-stream').Writable;\n\nvar constants = require('./constants');\n\nvar APPEND_MODE_REGEXP = /a/;\n\nfunction closeFd(propagatedErr, fd, callback) {\n  if (typeof fd !== 'number') {\n    return callback(propagatedErr);\n  }\n\n  fs.close(fd, onClosed);\n\n  function onClosed(closeErr) {\n    if (propagatedErr || closeErr) {\n      return callback(propagatedErr || closeErr);\n    }\n\n    callback();\n  }\n}\n\nfunction isValidUnixId(id) {\n  if (typeof id !== 'number') {\n    return false;\n  }\n\n  if (id < 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getFlags(options) {\n  var flags = !options.append ? 'w' : 'a';\n  if (!options.overwrite) {\n    flags += 'x';\n  }\n  return flags;\n}\n\nfunction isFatalOverwriteError(err, flags) {\n  if (!err) {\n    return false;\n  }\n\n  if (err.code === 'EEXIST' && flags[1] === 'x') {\n    // Handle scenario for file overwrite failures.\n    return false;\n  }\n\n  // Otherwise, this is a fatal error\n  return true;\n}\n\nfunction isFatalUnlinkError(err) {\n  if (!err || err.code === 'ENOENT') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getModeDiff(fsMode, vinylMode) {\n  var modeDiff = 0;\n\n  if (typeof vinylMode === 'number') {\n    modeDiff = (vinylMode ^ fsMode) & constants.MASK_MODE;\n  }\n\n  return modeDiff;\n}\n\nfunction getTimesDiff(fsStat, vinylStat) {\n\n  var mtime = date(vinylStat.mtime) || 0;\n  if (!mtime) {\n    return;\n  }\n\n  var atime = date(vinylStat.atime) || 0;\n  if (+mtime === +fsStat.mtime &&\n      +atime === +fsStat.atime) {\n    return;\n  }\n\n  if (!atime) {\n    atime = date(fsStat.atime) || undefined;\n  }\n\n  var timesDiff = {\n    mtime: vinylStat.mtime,\n    atime: atime,\n  };\n\n  return timesDiff;\n}\n\nfunction getOwnerDiff(fsStat, vinylStat) {\n  if (!isValidUnixId(vinylStat.uid) &&\n      !isValidUnixId(vinylStat.gid)) {\n    return;\n  }\n\n  if ((!isValidUnixId(fsStat.uid) && !isValidUnixId(vinylStat.uid)) ||\n      (!isValidUnixId(fsStat.gid) && !isValidUnixId(vinylStat.gid))) {\n    return;\n  }\n\n  var uid = fsStat.uid; // Default to current uid.\n  if (isValidUnixId(vinylStat.uid)) {\n    uid = vinylStat.uid;\n  }\n\n  var gid = fsStat.gid; // Default to current gid.\n  if (isValidUnixId(vinylStat.gid)) {\n    gid = vinylStat.gid;\n  }\n\n  if (uid === fsStat.uid &&\n      gid === fsStat.gid) {\n    return;\n  }\n\n  var ownerDiff = {\n    uid: uid,\n    gid: gid,\n  };\n\n  return ownerDiff;\n}\n\nfunction isOwner(fsStat) {\n  var hasGetuid = (typeof process.getuid === 'function');\n  var hasGeteuid = (typeof process.geteuid === 'function');\n\n  // If we don't have either, assume we don't have permissions.\n  // This should only happen on Windows.\n  // Windows basically noops fchmod and errors on futimes called on directories.\n  if (!hasGeteuid && !hasGetuid) {\n    return false;\n  }\n\n  var uid;\n  if (hasGeteuid) {\n    uid = process.geteuid();\n  } else {\n    uid = process.getuid();\n  }\n\n  if (fsStat.uid !== uid && uid !== 0) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction reflectStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.stat(path, onStat);\n\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    }\n\n    file.stat = stat;\n    callback();\n  }\n}\n\nfunction reflectLinkStat(path, file, callback) {\n  // Set file.stat to the reflect current state on disk\n  fs.lstat(path, onLstat);\n\n  function onLstat(lstatErr, stat) {\n    if (lstatErr) {\n      return callback(lstatErr);\n    }\n\n    file.stat = stat;\n    callback();\n  }\n}\n\nfunction updateMetadata(fd, file, callback) {\n\n  fs.fstat(fd, onStat);\n\n  function onStat(statErr, stat) {\n    if (statErr) {\n      return callback(statErr);\n    }\n\n    // Check if mode needs to be updated\n    var modeDiff = getModeDiff(stat.mode, file.stat.mode);\n\n    // Check if atime/mtime need to be updated\n    var timesDiff = getTimesDiff(stat, file.stat);\n\n    // Check if uid/gid need to be updated\n    var ownerDiff = getOwnerDiff(stat, file.stat);\n\n    // Set file.stat to the reflect current state on disk\n    assign(file.stat, stat);\n\n    // Nothing to do\n    if (!modeDiff && !timesDiff && !ownerDiff) {\n      return callback();\n    }\n\n    // Check access, `futimes`, `fchmod` & `fchown` only work if we own\n    // the file, or if we are effectively root (`fchown` only when root).\n    if (!isOwner(stat)) {\n      return callback();\n    }\n\n    if (modeDiff) {\n      return mode();\n    }\n    if (timesDiff) {\n      return times();\n    }\n    owner();\n\n    function mode() {\n      var mode = stat.mode ^ modeDiff;\n\n      fs.fchmod(fd, mode, onFchmod);\n\n      function onFchmod(fchmodErr) {\n        if (!fchmodErr) {\n          file.stat.mode = mode;\n        }\n        if (timesDiff) {\n          return times(fchmodErr);\n        }\n        if (ownerDiff) {\n          return owner(fchmodErr);\n        }\n        callback(fchmodErr);\n      }\n    }\n\n    function times(propagatedErr) {\n      fs.futimes(fd, timesDiff.atime, timesDiff.mtime, onFutimes);\n\n      function onFutimes(futimesErr) {\n        if (!futimesErr) {\n          file.stat.atime = timesDiff.atime;\n          file.stat.mtime = timesDiff.mtime;\n        }\n        if (ownerDiff) {\n          return owner(propagatedErr || futimesErr);\n        }\n        callback(propagatedErr || futimesErr);\n      }\n    }\n\n    function owner(propagatedErr) {\n      fs.fchown(fd, ownerDiff.uid, ownerDiff.gid, onFchown);\n\n      function onFchown(fchownErr) {\n        if (!fchownErr) {\n          file.stat.uid = ownerDiff.uid;\n          file.stat.gid = ownerDiff.gid;\n        }\n        callback(propagatedErr || fchownErr);\n      }\n    }\n  }\n}\n\nfunction symlink(srcPath, destPath, opts, callback) {\n  // Because fs.symlink does not allow atomic overwrite option with flags, we\n  // delete and recreate if the link already exists and overwrite is true.\n  if (opts.flags === 'w') {\n    // TODO What happens when we call unlink with windows junctions?\n    fs.unlink(destPath, onUnlink);\n  } else {\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n\n  function onUnlink(unlinkErr) {\n    if (isFatalUnlinkError(unlinkErr)) {\n      return callback(unlinkErr);\n    }\n    fs.symlink(srcPath, destPath, opts.type, onSymlink);\n  }\n\n  function onSymlink(symlinkErr) {\n    if (isFatalOverwriteError(symlinkErr, opts.flags)) {\n      return callback(symlinkErr);\n    }\n    callback();\n  }\n}\n\n/*\n  Custom writeFile implementation because we need access to the\n  file descriptor after the write is complete.\n  Most of the implementation taken from node core.\n */\nfunction writeFile(filepath, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (!Buffer.isBuffer(data)) {\n    return callback(new TypeError('Data must be a Buffer'));\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  // Default the same as node\n  var mode = options.mode || constants.DEFAULT_FILE_MODE;\n  var flags = options.flags || 'w';\n  var position = APPEND_MODE_REGEXP.test(flags) ? null : 0;\n\n  fs.open(filepath, flags, mode, onOpen);\n\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      return onComplete(openErr);\n    }\n\n    fs.write(fd, data, 0, data.length, position, onComplete);\n\n    function onComplete(writeErr) {\n      callback(writeErr, fd);\n    }\n  }\n}\n\nfunction createWriteStream(path, options, flush) {\n  return new WriteStream(path, options, flush);\n}\n\n// Taken from node core and altered to receive a flush function and simplified\n// To be used for cleanup (like updating times/mode/etc)\nfunction WriteStream(path, options, flush) {\n  // Not exposed so we can avoid the case where someone doesn't use `new`\n\n  if (typeof options === 'function') {\n    flush = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  Writable.call(this, options);\n\n  this.flush = flush;\n  this.path = path;\n\n  this.mode = options.mode || constants.DEFAULT_FILE_MODE;\n  this.flags = options.flags || 'w';\n\n  // Used by node's `fs.WriteStream`\n  this.fd = null;\n  this.start = null;\n\n  this.open();\n\n  // Dispose on finish.\n  this.once('finish', this.close);\n}\n\nutil.inherits(WriteStream, Writable);\n\nWriteStream.prototype.open = function() {\n  var self = this;\n\n  fs.open(this.path, this.flags, this.mode, onOpen);\n\n  function onOpen(openErr, fd) {\n    if (openErr) {\n      self.destroy();\n      self.emit('error', openErr);\n      return;\n    }\n\n    self.fd = fd;\n    self.emit('open', fd);\n  }\n};\n\n// Use our `end` method since it is patched for flush\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\nWriteStream.prototype._destroy = function(err, cb) {\n  this.close(function(err2) {\n    cb(err || err2);\n  });\n};\n\nWriteStream.prototype.close = function(cb) {\n  var that = this;\n\n  if (cb) {\n    this.once('close', cb);\n  }\n\n  if (this.closed || typeof this.fd !== 'number') {\n    if (typeof this.fd !== 'number') {\n      this.once('open', closeOnOpen);\n      return;\n    }\n\n    return process.nextTick(function() {\n      that.emit('close');\n    });\n  }\n\n  this.closed = true;\n\n  fs.close(this.fd, function(er) {\n    if (er) {\n      that.emit('error', er);\n    } else {\n      that.emit('close');\n    }\n  });\n\n  this.fd = null;\n};\n\nWriteStream.prototype._final = function(callback) {\n  if (typeof this.flush !== 'function') {\n    return callback();\n  }\n\n  this.flush(this.fd, callback);\n};\n\nfunction closeOnOpen() {\n  this.close();\n}\n\nWriteStream.prototype._write = function(data, encoding, callback) {\n  var self = this;\n\n  // This is from node core but I have no idea how to get code coverage on it\n  if (!Buffer.isBuffer(data)) {\n    return this.emit('error', new Error('Invalid data'));\n  }\n\n  if (typeof this.fd !== 'number') {\n    return this.once('open', onOpen);\n  }\n\n  fs.write(this.fd, data, 0, data.length, null, onWrite);\n\n  function onOpen() {\n    self._write(data, encoding, callback);\n  }\n\n  function onWrite(writeErr) {\n    if (writeErr) {\n      self.destroy();\n      callback(writeErr);\n      return;\n    }\n\n    callback();\n  }\n};\n\nmodule.exports = {\n  closeFd: closeFd,\n  isValidUnixId: isValidUnixId,\n  getFlags: getFlags,\n  isFatalOverwriteError: isFatalOverwriteError,\n  isFatalUnlinkError: isFatalUnlinkError,\n  getModeDiff: getModeDiff,\n  getTimesDiff: getTimesDiff,\n  getOwnerDiff: getOwnerDiff,\n  isOwner: isOwner,\n  reflectStat: reflectStat,\n  reflectLinkStat: reflectLinkStat,\n  updateMetadata: updateMetadata,\n  symlink: symlink,\n  writeFile: writeFile,\n  createWriteStream: createWriteStream,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}